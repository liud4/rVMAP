---
title: "MAP Data: Merge, Derive, and Label"
subtitle: "Draft"
author:
- name: '[Omair A. Khan, MAS](omair.a.khan@vumc.org)'
- name: '[Dandan Liu, PhD](dandan.liu@vanderbilt.edu)'
date: "Created: 20180503 | Last Modified: `r format(Sys.time(), '%Y%m%d')`"
output:
  html_notebook:
    code_folding: hide
    theme: lumen
    number_sections: yes
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: true
---

<!-- ##%#########################################################%## -->
<!-- # Template: MAP Data: Merge, Derive, and Label                # -->
<!-- #                                                             # -->
<!-- # Description: This script is run quarterly to merge, derive, # -->
<!-- #   and label the MAP data. The script requires the VMACr     # -->
<!-- #   package. It is configured to optionally perform the data  # -->
<!-- #   freeze as well.                                           # -->
<!-- #                                                             # -->
<!-- # Status: Currently non-functional. This is a draft that      # -->
<!-- #    includes legacy code from L. Samuels that needs to be    # -->
<!-- #    modernized before it can be used. (20180507)             # -->
<!-- ##%#########################################################%## -->

<style type="text/css">
 #TOC{
   position:fixed;
   top:0;
   // left:0;
   right:0;
   margin: 32px 20px 20px 20px;
   z-index: 9;
   // display:none;
  }
  #toc-toggle{
    position:fixed;
    top:0;
    // left:0;
    right:0;
    margin: 5px 20px 5px 20px;
  }
  .col-md-3{
    width: 0%;
  }
  .col-md-9{
    width: 100%;
  }
  div.container-fluid.main-container{
    max-width:none;
    margin-left:0px;
    margin-right:none;
  }
  div.plot-container{
    margin-left:50px;
    margin-bottom:20px;
  }
  h1.title{
    max-width:950px;
  }
  li.tocify-item{
    text-indent:0px;
  }
  #toc-toggle{
    z-index:9;
  }
  .tocify-subheader, .tocify-item, .tocify, .list-group-item{
  font-size:12pt;
  }
</style>

<button id="toc-toggle" type="button" class="btn btn-default btn-xs code-folding-btn pull-right collapsed" onclick="toggletoc()"><span>Table of Contents (click to hide/show)</span></button>

<script>
function toggletoc(){
$("#TOC").toggle();
}
</script>

```{r setup, echo = TRUE, results = 'hide'}
# clear environment
rm(list = ls())
options(datadist = NULL)

##%######################################################%##
####                modifiable settings                 ####
# modify this variable as follows: quarterly scheduled merge = {TRUE}; off-cycle merge = {FALSE}
quarterly.merge <- TRUE
# modify one of these variables to download data or specify a specific raw data file to merge
download.data <- FALSE
data.freeze.date <- NULL # in {yyyymmdd} format
# modify this variable to specify a specific data merge file to compare the new one with
last.data.merge.suffix <- NULL  # in d{yyyymmdd}_m{yyyymmdd} format
####                                                    ####
##%######################################################%##

# load packages
list.of.packages <- as.character(expression(
  knitr, dplyr, lubridate, tidyr, stringr, daff, Hmisc
))
load_pkg(list.of.packages)

devtools::load_all()

# set timezone
Sys.setenv(TZ = 'US/Central')

# set seed
set.seed(20140728) # this number was set by L. Samuels in the previous version of this code

# Hmisc options
options(
  prType = 'html', 
  grType = 'plotly',
  digits = 7,
  contrasts = c("contr.treatment", "contr.treatment")
)

# define important directories
## base directories
box.dir  <- file.path("~", "box")
vmac.dir <- file.path(box.dir, "VMAC BIOSTAT")
func.dir <- useful.dir <- file.path(vmac.dir, "Useful Code")
## data directories
data.dir <- file.path(vmac.dir, "DATA", "MAP")
data.raw.dir <- ifelse(quarterly.merge,
                       file.path(data.dir, "rawData"),
                       file.path(data.dir, "rawData", "temp"))
data.merge.dir <- file.path(data.dir, 'mergedData')
```

```{r load-functions}
# source(file.path(functiondir, "merge-scoringFunctions.R"))
# source(file.path(functiondir, "merge-missingsFunctions.R"))
# source(file.path(functiondir, "merge-miscUtilityFunctions.R"))
# source(file.path(functiondir, "merge-dates.R"))
# source(file.path(functiondir, "merge-callFunction.R"))
# source(file.path(functiondir, "merge-mergeWithinEpoch_new.R"))
# source(file.path(functiondir, "merge-comparisonFunctions.R"))
# source(file.path(functiondir, "merge-coerceAndStack.R"))
```

```{r finish-setup}
if (download.data == TRUE) {
  # specify data freeze date
  data.freeze.date <- format(Sys.time(), "%Y%m%d")
  # load raw data
  MAPfreeze.list <- data_freeze(quarterly.merge = FALSE, save = TRUE)
} else if (download.data == FALSE & is.null(data.freeze.date)) {
  # get path to most recent REDCap freeze
  data.freeze.file <- file.info(
    list.files(
      path = data.raw.dir, 
      pattern = "MAPfreeze_\\d{8}.rds",
      full.names = T
    )
  ) %>%
    tibble::rownames_to_column(., var = "path") %>%
    arrange(desc(mtime)) %>% 
    filter(row_number() == 1) %>%
    pull(1)
  # extract data freeze date
  data.freeze.date <- stringr::str_extract(data.freeze.file, "\\d{8}")
  # load raw data
  MAPfreeze.list <- readRDS(data.freeze.file)
} else if (download.data == FALSE & !is.null(data.freeze.date)) {
  # data freeze date is user specified
  # load raw data
  MAPfreeze.list <- readRDS(
    file.path(
      data.raw.dir,
      "MAPfreeze_",
      data.freeze.date,
      ".rds"
    )
  )
} else {
  stop("Either `download.data` or `data.freeze.date` must be specified as TRUE or FALSE and a 8 digit yyyymmdd, respectively.")
}

# define paths for saving current merged files
data.merge.date <- format(Sys.time(), "%Y%m%d")
current.data.merge.suffix <- paste0("_d", data.freeze.date, "_m", data.merge.date)
# OAK 20180507 later, combine the fm and bh files into one taller dataset where nrows = n(map.id) + 25  and ncol = ncol(merged.data) + 1  # 25 is the number of breath hold participants and the extra column is whether the data is BH or not
data.merge.fm.file <- file.path(
  data.merge.dir, 
  paste0("MAP_fm", filename.date)
)
data.merge.bh.file <- file.path(
  data.merge.dir, 
  paste0("MAP_bh", filename.date)
)

if (is.null(last.data.merge.suffix)) {
  # extact date of previous data merge
  last.data.merge.suffix <- file.info(
    list.files(
      path = data.merge.dir,
      pattern = "MAP\\_bh\\_d\\d{8}\\_m\\d{8}.rds",
      full.names = T
    )
  ) %>%
    tibble::rownames_to_column(., var = "path") %>%
    arrange(desc(mtime)) %>%
    filter(row_number() == 1) %>%
    pull(1) %>%
    stringr::str_extract("(?<=(MAP\\_bh\\_))d\\d{8}\\_m\\d{8}")
}

# define path to previous merged datasets
last.data.merge.fm.file <- file.path(
  data.merge.dir, 
  paste0("MAP_fm_", last.data.merge.date)
)
last.data.merge.bh.file <- file.path(
  data.merge.dir, 
  paste0("MAP_bh_", last.data.merge.date)
)
```

# Overview

TODO: Explain what the different variables are here.

## Epoch Independent

TODO: Add description for what Epoch Independent means.

```{r list-projects-epoch0}
list(
  project = MAPfreeze.list[["epoch_0"]][["project"]],
  shortname = MAPfreeze.list[["epoch_0"]][["shortname"]]
) %>% rbind.data.frame()
```

## Epoch 1

```{r list-projects-epoch1}
list(
  project = MAPfreeze.list[["epoch_1"]][["project"]],
  shortname = MAPfreeze.list[["epoch_1"]][["shortname"]]
) %>% rbind.data.frame()
```

## Epoch 2

```{r list-projects-epoch2}
list(
  project = MAPfreeze.list[["epoch_2"]][["project"]],
  shortname = MAPfreeze.list[["epoch_2"]][["shortname"]]
) %>% rbind.data.frame()
```

## Epoch 3

```{r list-projects-epoch3}
list(
  project = MAPfreeze.list[["epoch_3"]][["project"]],
  shortname = MAPfreeze.list[["epoch_3"]][["shortname"]]
) %>% rbind.data.frame()
```

<!-- ## Epoch 4 -->

<!-- ```{r  list-projects-epoch4} -->
<!-- list( -->
<!--   project = MAPfreeze.list[["epoch_4"]][["project"]], -->
<!--   shortname = MAPfreeze.list[["epoch_4"]][["shortname"]] -->
<!-- ) %>% rbind.data.frame() -->
<!-- ``` -->

**NB: The remaining code is outdated and will need to be updated before this template can be used.**

# Data Merge

TODO: Explain

## Merge within Epoch 1

We will begin by merging the following data sets within Epoch 1:

TODO: 

```{r merge-within-epoch1}
mergeWithinEpoch_new(
  epoch = 1,
  main = MAPfreeze.list$epoch_1$data$main,
  save.file = epoch_1.rds,
  abp = MAPfreeze.list$epoch_1$data$abp.static,
  biomarkers = MAPfreeze.list$epoch_1$data$biomarkers,
  auto3T = MAPfreeze.list$epoch_1$data$auto3T,
  auto3TBH = MAPfreeze.list$epoch_1$data$auto3T.bh,
  man3T = MAPfreeze.list$epoch_1$data$man3T,
  man3TBH = MAPfreeze.list$epoch_1$data$man3T.bh,
  qmass = MAPfreeze.list$epoch_1$data$cardiac.mri,
  addendum = MAPfreeze.list$epoch_1$data$addendum,
  csf = MAPfreeze.list$epoch_1$data$csf,
  srt = MAPfreeze.list$epoch_1$data$srt.static
)
```

## Merge within Epoch 2

Next, we will merge the following data sets within Epoch 2:

TODO: 

```{r merge-within-epoch2}
mergeWithinEpoch_new(
  epoch = 2,
  main = MAPfreeze.list$epoch_2$data$main,
  save.file = epoch_2.rds,
  # abp = MAPfreeze.list$epoch_2$data$abp.static,
  biomarkers = MAPfreeze.list$epoch_2$data$biomarkers,
  auto3T = MAPfreeze.list$epoch_2$data$auto3T,
  # auto3TBH = MAPfreeze.list$epoch_2$data$auto3T.bh,
  man3T = MAPfreeze.list$epoch_2$data$man3T,
  # man3TBH = MAPfreeze.list$epoch_2$data$man3T.bh,
  qmass = MAPfreeze.list$epoch_2$data$cardiac.mri,
  # addendum = MAPfreeze.list$epoch_2$data$addendum,
  csf = MAPfreeze.list$epoch_2$data$csf,
  # srt = MAPfreeze.list$epoch_2$data$srt.static
)
```

## Merge within Epoch 3

We will repeat this process for teh following data sets within Epoch 3:

TODO: 


```{r merge-within-epoch3}
mergeWithinEpoch_new(
  epoch = 3,
  main = MAPfreeze.list$epoch_3$data$main,
  save.file = epoch_3.rds,
  # abp = MAPfreeze.list$epoch_3$data$abp.static,
  biomarkers = MAPfreeze.list$epoch_3$data$biomarkers,
  auto3T = MAPfreeze.list$epoch_3$data$auto3T,
  # auto3TBH = MAPfreeze.list$epoch_3$data$auto3T.bh,
  man3T = MAPfreeze.list$epoch_3$data$man3T,
  # man3TBH = MAPfreeze.list$epoch_3$data$man3T.bh,
  # qmass = MAPfreeze.list$epoch_3$data$cardiac.mri,
  # addendum = MAPfreeze.list$epoch_3$data$addendum,
  csf = MAPfreeze.list$epoch_3$data$csf,
  # srt = MAPfreeze.list$epoch_3$data$srt.static
)
```

## Merge across all epochs

In this section, we will compare and stack the merged Epoch data.

```{r merge-across-epochs}
# epoch1 <- readRDS(firstRdsEpoch1)
# allEpochs <- epoch1
```

### Compare and stack: Epoch 2 with Epoch 1

Here we refer to the Epoch 2 data as "new" and the previous epochs (Epoch 1) as "old."

Ignore warning messages about NAs introduced by coercion: <!-- OAK 20180507: Legacy code. TODO: Modernize to prevent this warning. -->

```{r compare-epoch1-epoch2}
# epoch2 <- readRDS(firstRdsEpoch2)

# TODO: is this necessary?
epoch_2 <- within(epoch_2, {
  cmr.findings.pulse <- as.numeric(cmr.findings.pulse)
  abp.date <- NA
})

# compareVarnames(newdat = epoch2, olddat = allEpochs)
# compareIDs(newdat = epoch2, olddat = allEpochs)
# compareFactors(newdat = epoch2, olddat = allEpochs)

compare_data(epoch_2.df, epoch_1.df)
```

```{r coerce-stack-epoch1-epoch2}
# allEpochs <- coerceAndStack(newdat = epoch2, olddat = allEpochs)
merged.df <- coerceAndStack(newdat = epoch_2.df, olddat = epoch_1.df)
printAfterStackingText()
```

### Compare and stack: Epoch 3 with Epochs 1 and 2

Here we refer to the Epoch 3 data as "new" and the previous epochs (Epochs 1 and 2) as "old."

Ignore warning messages about NAs introduced by coercion: <!-- OAK 20180507: Legacy code. TODO: Modernize to prevent this warning. -->

```{r compare-epoch12-epoch3}
# epoch3 <- readRDS(firstRdsEpoch3)

# TODO: Is this necessary?
epoch_3 <- within(epoch_3, {
  cmr.findings.pulse <- as.numeric(cmr.findings.pulse)
  abp.date <- NA
})

# compareVarnames(newdat = epoch3, olddat = allEpochs)
# compareIDs(newdat = epoch3, olddat = allEpochs)
# compareFactors(newdat = epoch3, olddat = allEpochs)

compare_data(epoch_3, allEpochs)
```

```{r coerce-stack-epoch12-epoch3}
# allEpochs <- coerceAndStack(newdat = epoch3, olddat = allEpochs)
merged.df <- coerceAndStack(newdat = epoch_3.df, olddat = merged.df)
printAfterStackingText()

pre-independent-data.merged.df.temp <- merged.df
```

## Merge Epoch independent data

TODO: Explain.

Ignore warning messages about NAs introduced by coercion: <!-- OAK 20180507: Legacy code. TODO: Modernize to prevent this warning. -->

### Add ABPM consent data

```{r}
tracking.static.df <- MAPfreeze.list$epoch_0$data$tracking.static

# TODO: after next download, the subsetting won't be nec.
tracking.static.subset.df <- tracking.static.df[, Cs(
  map_id, elig_visit_consent_abpm, elig_visit_consent_lp, elig_visit_consent_lp_ineligible
)]

# this file has numeric map_id... but no duplicates
# trackdat.subset <- within(trackdat.subset, {
#   map_id <- formatC(map_id, width = 3, format = "d", flag = "0")
# })

format_id(tracking.static.subset.df)

check_shared_vars(merged.df, tracking.static.subset.df, 'map.id')

# epochsPlus1 <- merge(
#   allEpochs, 
#   trackdat.subset,
#   by = "map.id", 
#   all.x = TRUE
# )

merged.df %<>% left_join(
  tracking.static.subset.df,
  by = "map_id"
)

# change to merged.epoch_1.df
epochsPlus1 <- within(epochsPlus1, {
  # TODO: We need to add to this when we are given the variable name for other epochs
  abp.consent <- ifelse(epoch == 1, elig.visit.consent.abpm, NA)
  abp.consent.factor <- factor(abp.consent, levels = c(1, 0), labels = c("Yes", "No")) 
})
```

### Add post-fixed eligibility data

```{r}
eligibility.static.df <- MAPfreeze.list$epoch_0$data$eligibility.static

# There are a ton of problems with their map.id
# eligdat <- within(eligdat, {
#   map.id <- as.numeric(map.id)
# })
# eligdat <- eligdat[!is.na(eligdat$map.id) & eligdat$map.id > 0, ]
# 
# eligdat <- within(eligdat, {
#   map.id <- formatC(map.id, width = 3, format = "d", flag = "0")
# })

format_id(eligibility.static.df)

# source(file.path(functiondir, "eligibility.R"))

eligibility.static.df <- modify_eligibility(eligibility.static.df)

check_shared_vars(epochsPlus1, eligibility.static.df, c('map.id'))

# merged.epoch_2.df <- merge(
#   merged.epoch_1.df, 
#   eligibility.static.df,
#   by = "map.id", 
#   all.x = TRUE
# )

merged.epoch_2.df <- left_join(
  merged.epoch_1.df,
  eligibility.static.df,
  by = "map_id"
)
```

### Add APOE data

```{r}
apoe.static.df <- MAPfreeze.list$epoch_0$data$apoe.static
# names(apoedat) <- gsub("\\_", "\\.", names(apoedat))

# apoedat <- within(apoedat, {
#   map.id <- formatC(map.id, width = 3, format = "d", flag = "0")
# })

format_id(apoe.static.df)

check_shared_vars(merged.epoch_2.df, apoe.static.df, 'map.id')

# alldat <- merge(
#   epochsPlus2, 
#   apoedat,
#   by = "map.id", 
#   all.x = TRUE
# )

merged.df <- left_join(
  merged.epoch_2.df,
  apoe.static.df,
  by = "map_id"
)
```

## Apply labels to raw data

```{r}
merged.df <- callFunction(
  "mainLabelsAndFactors", 
  functiondir, 
  "Apply labels and create factors for main REDCap dataset", 
  merged.df
)
```

# Derivation of New Variables

## Dates

```{r derive-dates}
# Note that the dates() function is also used in Elig. processing
alldat <- callFunction("dates", functiondir, "Convert dates", alldat)
alldat <- callFunction("datesDerived", functiondir, "Derive date variables", alldat)
```

## Demographics

```{r derive-demographic}
alldat <- callFunction("demog", functiondir, "Derive demographic variables", alldat)
```

## APOE

```{r derive-apoe}
alldat <- callFunction("apoe", functiondir, "Derive APOE variables", alldat)
```

## Medication and Surgery

```{r derive-medications-surgery}
alldat <- callFunction(
  "medicationAndSurgery", functiondir, "Derive medication and surgery variables", alldat,
  diabFile                        = diabFile,
  cholFile                        = cholFile,
  #antihypFile                    = antihypFile, # changed processing 07 Oct 2016
  afibFile                        = afibFile,
  afibsurgFile                    = afibsurgFile,
  antihypBetaBlockerFile          = antihypBetaBlockerFile,
  antihypBetaBlockerIfNotDropFile = antihypBetaBlockerIfNotDropFile,
  antihypACEInhibFile             = antihypACEInhibFile,
  antihypARBFile                  = antihypARBFile,
  antihypCCBFile                  = antihypCCBFile,
  antihypKSDFile                  = antihypKSDFile,
  antihypOtherFile                = antihypOtherFile
)
```

## Blood Values

```{r derive-apoe}
alldat <- callFunction("bloodConversion", functiondir, "Convert blood values", alldat)
```

## Medical History

```{r derive-apoe}
alldat <- callFunction("medhxEtc", functiondir, "Derive medical history variables, etc.", alldat)
```

## Cardiac Structure

```{r derive-apoe}
alldat <- callFunction("cardiacStructure", functiondir, "Derive a few echo variables", alldat)
```

## ABP QC

```{r derive-apoe}
alldat <- callFunction("abpqc", functiondir, "Derive ABP QC variables", alldat)
```

## FSRP

```{r derive-apoe}
alldat <- callFunction("fsrp", functiondir, "Derive FSRP", alldat)
```

## Cognitive Complaint, FCADL, and FAQ

```{r derive-apoe}
alldat <- callFunction("cognitiveComplaint", functiondir, "Derive complaint, fcadl, and faq variables", alldat)
```

## Neuropsych

```{r derive-apoe}
alldat <- callFunction("neuropsych", functiondir, "Derive neuropsych variables", alldat)
```

## Addendum

```{r derive-apoe}
alldat <- callFunction("addendum", functiondir, "Label addendum variables and create a few factor variables", alldat)
```

## MLTA and CHAMPS

```{r derive-apoe}
alldat <- callFunction("mltaChamps", functiondir, "Derive MLTA and CHAMPS variables", alldat)
```

## Depression

```{r derive-apoe}
alldat <- callFunction("depression", functiondir, "Derive depression variables", alldat)
```

## Biomarker

```{r derive-apoe}
alldat <- callFunction("biomarkers", functiondir, "Derive biomarker (csf and other) variables", alldat)
```

## Informant Information

```{r derive-apoe}
alldat <- callFunction("informantInfo", functiondir, "Derive informant information variables", alldat)
```

## Automated 3T

```{r derive-apoe}
alldat <- callFunction("automated3T", functiondir, "Derive automated 3T variables", alldat)
```

## Manual 3T

```{r derive-apoe}
alldat <- callFunction("manual3T", functiondir, "Derive manual 3T variables", alldat)
```

## Diagnosis and Staging

```{r derive-apoe}
alldat <- callFunction("diagnosisAndStaging", functiondir, "Derive diagnosis and staging variables", alldat)
```

## PSQI

```{r derive-apoe}
alldat <- callFunction("psqi", functiondir, "Derive PSQI variables", alldat)
```

## Frailty

```{r derive-apoe}
alldat <- callFunction("frailty", functiondir, "Derive frailty variables", alldat)
```

## Food Scan

```{r derive-apoe}
alldat <- callFunction("foodScan", functiondir, "Derive food scan variables", alldat)
```

## CMR and QMass

```{r derive-apoe}
alldat <- callFunction("cardiacMRI", functiondir, "Process cmr and qmass", alldat)
```

## PVLT

```{r derive-apoe}
alldat <- callFunction("pvlt", functiondir, "Process PVLT variables", alldat)
```

## SRT

```{r derive-apoe}
alldat <- callFunction("srt", functiondir, "Process SRT variables", alldat)
```

# Set invalid values to missing

```{r}
alldat <- callFunction("invalidNeuropsychElig", functiondir, "Set invalid eligibility neuropsych items to missing", alldat)
alldat <- callFunction("invalidNeuropsychAddendum", functiondir, "Set invalid neuropsych items from Addendum to missing", alldat)
alldat <- callFunction("invalidNeuropsychItems", functiondir, "Set invalid neuropsych items from main protocol to missing", alldat)
# TODO: All of these are neuropsych items, so it might make more sense to combine.
#     Also I think some of the code is duplicated. LS
alldat <- callFunction("invalidColorblind", functiondir, "Set invalid colorblindness-related items to missing", alldat)

# Drop unused factor levels, then re-apply the variable labels
oldlabels <- unlist(lapply(names(alldat), function(x) label(alldat[, x])))
names(oldlabels) <- names(alldat)

# 09 Dec 2016: Somewhere we are losing other labels
ep1labels <- unlist(lapply(names(epoch1), function(x) label(epoch1[, x])))
names(ep1labels) <- names(epoch1)

alldat <- droplevels(alldat)

for(vname in names(alldat)) {
  if (label(alldat[, vname]) == "") {
    label(alldat[, vname]) <- oldlabels[vname]
    # and if it's still null
    if (label(alldat[, vname]) == "") {
      label(alldat[, vname]) <- ep1labels[vname]
    }
  }
}
```

# Add baseline versions of certain variables onto every row

```{r repeatBaseline}
# Get certain enrollment (epoch 1) vars onto every row
# TODO: add to this list (see meeting minutes),
#    then do consistency checks for things that shouldn't change

enrollmentVarsThatShouldNotChange <- Cs(
  dob,
  education,
  sex.factor,
  raceethnicity.factor,
  usa.born.factor,
  lang.prim.factor
)

otherKeyEnrollmentVars <- Cs(
  # diagnosis.factor is handled separately because of diff. name
  mci.stage.factor, 
  albert.mci.stage.factor, 
  age
)

# If you change the order here, change it below too!
epoch1ToRepeat <- 
  alldat[alldat$epoch %in% 1, 
         c('map.id', 'diagnosis.factor', enrollmentVarsThatShouldNotChange, otherKeyEnrollmentVars)
         ]

for (vname in otherKeyEnrollmentVars) {
  label(epoch1ToRepeat[[vname]]) <- 
    paste0(label(epoch1ToRepeat[[vname]]), ", from Enrollment")
}

# note order above, and modify this as necessary!
# For backwards compatibility we are calling the enrollment
#  version of diagnosis.factor "enrolled.dx.factor" instead of
#  "enrolled.diagnosis.factor."
names(epoch1ToRepeat) <- c("map.id", "enrolled.dx.factor", 
                           paste0("enrolled.", c(enrollmentVarsThatShouldNotChange, otherKeyEnrollmentVars)))

alldat <- merge(alldat, epoch1ToRepeat, by = 'map.id')
```

The following variables were added to each row:

```{r}
data.frame(Variable = setdiff(names(epoch1ToRepeat), "map.id"), row.names = FALSE)
```

# Add memory composite score

```{r}
memoryfile <- file.path(
  rawdir,
  'Mem_Ef_scores_9-29.csv'
)

mem.composite <- read.csv(
  memoryfile, 
  header = TRUE
)

colnames(mem.composite) <- c("map.id", "epoch", "np.executive.composite", "np.memory.composite")
mem.composite$map.id <- formatC(mem.composite$map.id, width = 3, format = "d", flag = "0")

label(mem.composite$np.executive.composite) <- 'EF Composite'
label(mem.composite$np.memory.composite) <- 'Memory Composite'

alldat <- merge(alldat, mem.composite, by = c('map.id', 'epoch'), all.x = TRUE)

alldat[alldat$map.id == "209" & alldat$epoch == 1, 'np.memory.composite'] <- NA
```

# Add labels for derived variables

```{r}
nolabel <- names(alldat)[lapply(alldat, function(x) label(x)) == ""]

metadata_format <- function(data) {
  data %>%
    select(c("field_name", "field_type", "field_label", "select_choices_or_calculations")) %>%
    mutate(field_name = gsub("\\_", "\\.", field_name))
}

labels.0 <- lapply(MAPfreeze.list[["epoch_0"]][["metadata"]], metadata.select.fun) %>% bind_rows()
labels.1 <- lapply(MAPfreeze.list[["epoch_1"]][["metadata"]], metadata.select.fun) %>% bind_rows()
labels.2 <- lapply(MAPfreeze.list[["epoch_2"]][["metadata"]], metadata.select.fun) %>% bind_rows()
labels.3 <- lapply(MAPfreeze.list[["epoch_3"]][["metadata"]], metadata.select.fun) %>% bind_rows()

labels.all <- bind_rows(labels.0, labels.1, labels.2, labels.3) %>% 
  distinct() %>%
  filter(field_name %in% nolabel)

duplicated.names <- labels.all$field_name[duplicated(labels.all$field_name)]

labels.all <- filter(labels.all, field_name %nin% duplicated.names)

for (varname in labels.all$field_name) {
  Hmisc::label(alldat[, varname]) <- labels.all[labels.all$field_name == varname, "field_label", drop = TRUE]
}
```

# The merged file
```{r, saveFinalFiles}
# email from Kim, 23 Mar 2015: I recommend using data from MAP Automated 3T Brain MRI Breath Hold for MAP IDS 1-4, 6-10, and 12-25. This data was acquired at enrollment. MAP Automated 3T Brain MRI Epoch 1 is the enrollment dataset for MAP IDs 27-336. MAP 5, 11, 26, 31, 77, 177, 184, 190, and 201 had no imaging.
# In subsequent meetings, they explained that sometimes they will want to use the Breath Hold data for ids 1-25, and sometimes they won't.  We decided to make two files, one that uses the Breath Hold data for those 25 and one that doesn't.

# 20 Oct 2016 (LS)--- tweaking code
bHoldnames <- setdiff(names(alldat)[grep("^bHold\\.", names(alldat))], "bHold.scan.date")
bHoldIndices <- match(bHoldnames, names(alldat))

bHoldnamesWithCounterparts.temp <- bHoldnames[!(bHoldnames %in% c("bHold.session.id.11", "bHold.scan.date.11"))]
regnames.temp <- gsub("^bHold\\.", "", bHoldnamesWithCounterparts.temp)
regnames <- regnames.temp[regnames.temp %in% names(alldat)] # Identify counterpart that are actually in alldat
bHoldnamesWithCounterparts <- bHoldnamesWithCounterparts.temp[regnames.temp %in% names(alldat)]
# 19 Oct 2016: taking out this line--- it should not be necessary. LS
#regnames <- regnames[!(regnames %in% c("session.id.11", "scan.date.11"))]
reglabels <- label(alldat[, regnames])

# The file that uses the facemask 3T data for everyone
alldatMain <- alldat[, -bHoldIndices]

# The file that uses the Breath Hold epoch 1 data for ids 1-25
alldatbHold <- alldat

alldatbHold[alldat$epoch == 1 & as.numeric(alldat$map.id) <= 25, regnames] <- alldatbHold[alldat$epoch == 1 & as.numeric(alldat$map.id) <= 25, bHoldnamesWithCounterparts]

alldatbHold <- alldatbHold[, -bHoldIndices]

# OAK 20180224
# Add AD.sig variables once bHold data has been separated. This will prevent the regression error.
alldatMain <- callFunction("addADsig",
                           functiondir, 
                           "Derive AD.sig.mcevoy and AD.sig.schwarz after data is separated", 
                           alldatMain)
alldatbHold <- callFunction("addADsig",
                           functiondir,
                           "Derive AD.sig.mcevoy and AD.sig.schwarz after data is separated", 
                           alldatbHold)

# Save the files in two formats.
saveRDS(alldatMain, file = paste0(mergedfile, ".rds"))
write.csv(alldatMain, file = paste0(mergedfile, ".csv"), row.names = FALSE)

saveRDS(alldatbHold, file = paste0(breathHoldMergedfile, ".rds"))
write.csv(alldatbHold, file = paste0(breathHoldMergedfile, ".csv"), row.names = FALSE)
```

<!-- Add code for daff function. -->
