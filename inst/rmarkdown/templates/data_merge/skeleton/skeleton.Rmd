---
title: "MAP Data: Merge, Derive, and Label"
author:
- name: '[Omair A. Khan, MAS](omair.a.khan@vumc.org)'
- name: '[Dandan Liu, PhD](dandan.liu@vumc.org)'
date: "Created: `r format(Sys.time(), '%Y%m%d')`"
output:
  html_notebook:
    code_folding: hide
    theme: lumen
    number_sections: true
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
---

<style type="text/css">
 #TOC{
   position:fixed;
   top:0;
   // left:0;
   right:0;
   margin: 32px 20px 20px 20px;
   z-index: 9;
   // display:none;
  }
  #toc-toggle{
    position:fixed;
    top:0;
    // left:0;
    right:0;
    margin: 5px 20px 5px 20px;
  }
  .col-md-3{
    width: 0%;
  }
  .col-md-9{
    width: 100%;
  }
  div.container-fluid.main-container{
    max-width:none;
    margin-left:0px;
    margin-right:none;
  }
  div.plot-container{
    margin-left:50px;
    margin-bottom:20px;
  }
  h1.title{
    max-width:950px;
  }
  li.tocify-item{
    text-indent:0px;
  }
  #toc-toggle{
    z-index:9;
  }
  .tocify-subheader, .tocify-item, .tocify, .list-group-item{
  font-size:12pt;
  }
</style>

<button id="toc-toggle" type="button" class="btn btn-default btn-xs code-folding-btn pull-right collapsed" onclick="toggletoc()"><span>Table of Contents (click to hide/show)</span></button>

<script>
function toggletoc(){
$("#TOC").toggle();
}
</script>

```{r setup, echo = TRUE, results = 'hide'}
# define important directories
## base directories
box.dir  <- file.path("~", "box")
vmac.dir <- file.path(box.dir, "VMAC BIOSTAT")
## data directories
data.dir <- file.path(vmac.dir, "DATA", "MAP")

##%######################################################%##
####                modifiable settings                 ####
# quarterly scheduled merge, TRUE; off-cycle merge, FALSE
quarterly.download <- TRUE
# modify one of these variables to download data or specify a specific raw data file to use for merging
download.data <- FALSE
data.freeze.date <- yyyymmdd # in {yyyymmdd} format
# modify both of these variables to specify a specific data merge file to compare the new one with
last.data.download.date <- yyyymmdd # in {yyyymmdd} format
last.data.merge.date <- yyyymmdd # in {yyyymmdd} format

map_163_invalidation.file <- file.path(data.dir, "Documentation", "MAP163_variablesunusable.xlsx")
####                                                    ####
##%######################################################%##

packages <- Hmisc::Cs(
  knitr,
  dplyr,
  lubridate,
  tidyr,
  stringr,
  magrittr,
  daff,
  Hmisc,
  formattable,
  REDCapR,
  secret,
  arsenal,
  fs
)

rVMAP::load_pkg(packages)

devtools::load_all(path = file.path("~", "dev", "rVMAP"))

# set timezone
Sys.setenv(TZ = 'US/Central')

# Hmisc options
options(
  prType = 'html', 
  grType = 'plotly',
  digits = 6,
  contrasts = c("contr.treatment", "contr.treatment")
)

# define additional important directories
## data directories

data.raw.dir <- file.path(data.dir, "rawData")
data.merge.dir <- file.path(data.dir, 'mergedData')
```

```{r finish-setup}
if (download.data == TRUE) {
  # specify data freeze date
  data.freeze.date <- format(Sys.time(), "%Y%m%d")
  # load raw data
  MAPfreeze.list <- data_freeze(quarterly.download = quarterly.download, save = TRUE)
} else if (download.data == FALSE & is.null(data.freeze.date)) {
  # get path to most recent REDCap freeze
  data.freeze.file <- file.info(
    list.files(
      path = data.raw.dir, 
      pattern = "MAPfreeze_\\d{8}.rds",
      full.names = T
    )
  ) %>%
    tibble::rownames_to_column(., var = "path") %>%
    arrange(desc(mtime)) %>% 
    filter(row_number() == 1) %>%
    pull(1)
  # extract data freeze date
  data.freeze.date <- stringr::str_extract(data.freeze.file, "\\d{8}")
  # load raw data
  MAPfreeze.list <- readRDS(data.freeze.file)
} else if (download.data == FALSE & !is.null(data.freeze.date)) {
  # data freeze date is user specified
  # load raw data
  MAPfreeze.list <- readRDS(
    file.path(
      data.raw.dir,
      paste0(
        "MAPfreeze_", 
        data.freeze.date, 
        ".rds"
      )
    )
  )
} else {
  stop("Either `download.data` or `data.freeze.date` must be specified as TRUE or FALSE and a 8 digit yyyymmdd, respectively.")
}

# define paths for saving current merged files
data.merge.date <- format(Sys.time(), "%Y%m%d")
current.data.merge.suffix <- paste0("_d", data.freeze.date, "_m", data.merge.date)

merge.report.dir <- file.path(data.merge.dir, paste0("MAP_data_merge", current.data.merge.suffix))

dir_create(merge.report.dir)

data.merge.fm.file <- file.path(
  data.merge.dir, 
  paste0("MAP_fm_d", data.freeze.date, "_m", data.merge.date)
)
data.merge.bh.file <- file.path(
  data.merge.dir, 
  paste0("MAP_bh_d", data.freeze.date, "_m", data.merge.date)
)

if (!is.null(last.data.download.date) & is.null(last.data.merge.date)) {
  error("Please specify the last data merge date.")
} else if (is.null(last.data.download.date) & !is.null(last.data.merge.date)) {
  error("Please specify the last data download date.")
} else if (is.null(last.data.download.date) & is.null(last.data.merge.date)) {
  # extract date of previous data merge
  last.data.merge.suffix <- file.info(
    list.files(
      path = data.merge.dir,
      pattern = "MAP\\_bh\\_d\\d{8}\\_m\\d{8}.rds",
      full.names = T
    )
  ) %>%
    tibble::rownames_to_column(., var = "path") %>%
    arrange(desc(mtime)) %>%
    filter(row_number() == 1) %>%
    pull(1) %>%
    stringr::str_extract("(?<=(MAP\\_bh\\_))d\\d{8}\\_m\\d{8}")
} else {
  last.data.merge.suffix <- paste0("d", last.data.download.date, "_m", last.data.merge.date)
}

# define path to previous merged datasets
last.data.merge.fm.file <- file.path(
  data.merge.dir, 
  paste0("MAP_fm_", last.data.merge.suffix)
)
last.data.merge.bh.file <- file.path(
  data.merge.dir, 
  paste0("MAP_bh_", last.data.merge.suffix)
)
```

# Overview of Available Data

The raw data to be used in this script was downloaded from REDCap on `r strsplit(MAPfreeze.list$general$timestamp, "\\ ")[[1]][1]` at `r strsplit(MAPfreeze.list$general$timestamp, "\\ ")[[1]][2]` by user `r MAPfreeze.list$general$sysinfo[["login"]]` using `r MAPfreeze.list$general$versions[["R"]]`.

## Epoch Independent

The following is a list of available data sets to be merged that can be considered independent of any specific time period. The suffix, ".static", indicates that the data set was manually saved at some time and is therefore a static representation of the data.

```{r list-projects-epoch0}
list(
  project = MAPfreeze.list[["epoch_0"]][["project"]],
  shortname = MAPfreeze.list[["epoch_0"]][["shortname"]]
) %>% rbind.data.frame()
```

## Epoch 1

The following is a list of available data sets to be merged that were collected during Epoch 1.

```{r list-projects-epoch1}
list(
  project = MAPfreeze.list[["epoch_1"]][["project"]],
  shortname = MAPfreeze.list[["epoch_1"]][["shortname"]]
) %>% rbind.data.frame()
```

## Epoch 2

The following is a list of available data sets to be merged that were collected during Epoch 2.

```{r list-projects-epoch2}
list(
  project = MAPfreeze.list[["epoch_2"]][["project"]],
  shortname = MAPfreeze.list[["epoch_2"]][["shortname"]]
) %>% rbind.data.frame()
```

## Epoch 3

The following is a list of available data sets to be merged that were collected during Epoch 3.

```{r list-projects-epoch3}
list(
  project = MAPfreeze.list[["epoch_3"]][["project"]],
  shortname = MAPfreeze.list[["epoch_3"]][["shortname"]]
) %>% rbind.data.frame()
```

## Epoch 4

The following is a list of available data sets to be merged that were collected during Epoch 4.

```{r list-projects-epoch4}
list(
  project = MAPfreeze.list[["epoch_4"]][["project"]],
  shortname = MAPfreeze.list[["epoch_4"]][["shortname"]]
) %>% rbind.data.frame()
```

## Epoch 5

The following is a list of available data sets to be merged that were collected during Epoch 5.

```{r list-projects-epoch5}
list(
  project = MAPfreeze.list[["epoch_5"]][["project"]],
  shortname = MAPfreeze.list[["epoch_5"]][["shortname"]]
) %>% rbind.data.frame()
```

# Process Raw Data {.tabset .tabset-fade .tabset-pills}

We begin by processing a subset of raw data sets within each available epoch. The `process_raw_data()` function tidies each inputted data set, formats certain variables, and sets some VMAC-specified values to missing.

## Process Epoch 1 Raw Data

```{r process-epoch1}
process_raw_data(
  epoch = 1,
  main = MAPfreeze.list$epoch_1$data$main,
  abp = MAPfreeze.list$epoch_1$data$abp.static,
  biomarkers = MAPfreeze.list$epoch_1$data$biomarkers,
  auto3T = MAPfreeze.list$epoch_1$data$auto3T,
  auto3TBH = MAPfreeze.list$epoch_1$data$auto3T.bh,
  man3T = MAPfreeze.list$epoch_1$data$man3T,
  man3TBH = MAPfreeze.list$epoch_1$data$man3T.bh,
  qmass = MAPfreeze.list$epoch_1$data$cardiac.mri,
  addendum = MAPfreeze.list$epoch_1$data$addendum,
  csf = MAPfreeze.list$epoch_1$data$csf,
  srt = MAPfreeze.list$epoch_1$data$srt.static
)
```

## Process Epoch 2 Raw Data

```{r process-epoch2}
process_raw_data(
  epoch = 2,
  main = MAPfreeze.list$epoch_2$data$main,
  # abp = MAPfreeze.list$epoch_2$data$abp.static,
  biomarkers = MAPfreeze.list$epoch_2$data$biomarkers,
  auto3T = MAPfreeze.list$epoch_2$data$auto3T,
  # auto3TBH = MAPfreeze.list$epoch_2$data$auto3T.bh,
  man3T = MAPfreeze.list$epoch_2$data$man3T,
  # man3TBH = MAPfreeze.list$epoch_2$data$man3T.bh,
  qmass = MAPfreeze.list$epoch_2$data$cardiac.mri,
  # addendum = MAPfreeze.list$epoch_2$data$addendum,
  csf = MAPfreeze.list$epoch_2$data$csf
  # srt = MAPfreeze.list$epoch_2$data$srt.static
)
```

## Process Epoch 3 Raw Data

```{r process-epoch3}
process_raw_data(
  epoch = 3,
  main = MAPfreeze.list$epoch_3$data$main,
  # abp = MAPfreeze.list$epoch_3$data$abp.static,
  biomarkers = MAPfreeze.list$epoch_3$data$biomarkers,
  auto3T = MAPfreeze.list$epoch_3$data$auto3T,
  # auto3TBH = MAPfreeze.list$epoch_3$data$auto3T.bh,
  man3T = MAPfreeze.list$epoch_3$data$man3T,
  # man3TBH = MAPfreeze.list$epoch_3$data$man3T.bh,
  qmass = MAPfreeze.list$epoch_3$data$cardiac.mri,
  # addendum = MAPfreeze.list$epoch_3$data$addendum,
  csf = MAPfreeze.list$epoch_3$data$csf
  # srt = MAPfreeze.list$epoch_3$data$srt.static
)
```

## Process Epoch 4 Raw Data

```{r process-epoch4}
process_raw_data(
  epoch = 4,
  main = MAPfreeze.list$epoch_4$data$main,
  # abp = MAPfreeze.list$epoch_4$data$abp.static,
  # biomarkers = MAPfreeze.list$epoch_4$data$biomarkers,
  auto3T = MAPfreeze.list$epoch_4$data$auto3T,
  # auto3TBH = MAPfreeze.list$epoch_4$data$auto3T.bh,
  man3T = MAPfreeze.list$epoch_4$data$man3T,
  # man3TBH = MAPfreeze.list$epoch_4$data$man3T.bh,
  qmass = MAPfreeze.list$epoch_4$data$cardiac.mri,
  # addendum = MAPfreeze.list$epoch_4$data$addendum,
  csf = MAPfreeze.list$epoch_4$data$csf
  # srt = MAPfreeze.list$epoch_4$data$srt.static
)
```

## Process Epoch 5 Raw Data

```{r process-epoch5}
process_raw_data(
  epoch = 5,
  main = MAPfreeze.list$epoch_5$data$main,
  # abp = MAPfreeze.list$epoch_5$data$abp.static,
  # biomarkers = MAPfreeze.list$epoch_5$data$biomarkers,
  auto3T = MAPfreeze.list$epoch_5$data$auto3T,
  # auto3TBH = MAPfreeze.list$epoch_5$data$auto3T.bh,
  man3T = MAPfreeze.list$epoch_5$data$man3T,
  # man3TBH = MAPfreeze.list$epoch_5$data$man3T.bh,
  # qmass = MAPfreeze.list$epoch_5$data$cardiac.mri,
  # addendum = MAPfreeze.list$epoch_5$data$addendum,
  csf = MAPfreeze.list$epoch_5$data$csf
  # srt = MAPfreeze.list$epoch_5$data$srt.static
)
```

# Data Merge {.tabset .tabset-fade .tabset-pills}

Next, with the processing of raw data complete, we will merge the processed data sets within each available epoch. This is handled by the `merge_within_epoch()` function.

## Merge within Epoch 1

```{r merge-within-epoch1}
epoch_1_merge.df <- merge_within_epoch(
  epoch = 1,
  main = MAPfreeze.list$epoch_1$data$main,
  abp = MAPfreeze.list$epoch_1$data$abp.static,
  biomarkers = MAPfreeze.list$epoch_1$data$biomarkers,
  auto3T = MAPfreeze.list$epoch_1$data$auto3T,
  auto3TBH = MAPfreeze.list$epoch_1$data$auto3T.bh,
  man3T = MAPfreeze.list$epoch_1$data$man3T,
  man3TBH = MAPfreeze.list$epoch_1$data$man3T.bh,
  qmass = MAPfreeze.list$epoch_1$data$cardiac.mri,
  addendum = MAPfreeze.list$epoch_1$data$addendum,
  csf = MAPfreeze.list$epoch_1$data$csf,
  srt = MAPfreeze.list$epoch_1$data$srt.static
)
```

## Merge within Epoch 2

```{r merge-within-epoch2}
epoch_2_merge.df <- merge_within_epoch(
  epoch = 2,
  main = MAPfreeze.list$epoch_2$data$main,
  # abp = MAPfreeze.list$epoch_2$data$abp.static,
  biomarkers = MAPfreeze.list$epoch_2$data$biomarkers,
  auto3T = MAPfreeze.list$epoch_2$data$auto3T,
  # auto3TBH = MAPfreeze.list$epoch_2$data$auto3T.bh,
  man3T = MAPfreeze.list$epoch_2$data$man3T,
  # man3TBH = MAPfreeze.list$epoch_2$data$man3T.bh,
  qmass = MAPfreeze.list$epoch_2$data$cardiac.mri,
  # addendum = MAPfreeze.list$epoch_2$data$addendum,
  csf = MAPfreeze.list$epoch_2$data$csf
  # srt = MAPfreeze.list$epoch_2$data$srt.static
)
```

## Merge within Epoch 3

```{r merge-within-epoch3}
epoch_3_merge.df <- merge_within_epoch(
  epoch = 3,
  main = MAPfreeze.list$epoch_3$data$main,
  # abp = MAPfreeze.list$epoch_3$data$abp.static,
  biomarkers = MAPfreeze.list$epoch_3$data$biomarkers,
  auto3T = MAPfreeze.list$epoch_3$data$auto3T,
  # auto3TBH = MAPfreeze.list$epoch_3$data$auto3T.bh,
  man3T = MAPfreeze.list$epoch_3$data$man3T,
  # man3TBH = MAPfreeze.list$epoch_3$data$man3T.bh,
  qmass = MAPfreeze.list$epoch_3$data$cardiac.mri,
  # addendum = MAPfreeze.list$epoch_3$data$addendum,
  csf = MAPfreeze.list$epoch_3$data$csf
  # srt = MAPfreeze.list$epoch_3$data$srt.static
)
```

## Merge within Epoch 4

```{r merge-within-epoch4}
epoch_4_merge.df <- merge_within_epoch(
  epoch = 4,
  main = MAPfreeze.list$epoch_4$data$main,
  # abp = MAPfreeze.list$epoch_4$data$abp.static,
  # biomarkers = MAPfreeze.list$epoch_4$data$biomarkers,
  auto3T = MAPfreeze.list$epoch_4$data$auto3T,
  # auto3TBH = MAPfreeze.list$epoch_4$data$auto3T.bh,
  man3T = MAPfreeze.list$epoch_4$data$man3T,
  # man3TBH = MAPfreeze.list$epoch_4$data$man3T.bh,
  qmass = MAPfreeze.list$epoch_4$data$cardiac.mri,
  # addendum = MAPfreeze.list$epoch_4$data$addendum,
  csf = MAPfreeze.list$epoch_4$data$csf
  # srt = MAPfreeze.list$epoch_4$data$srt.static
)
```

## Merge within Epoch 5

```{r merge-within-epoch5}
epoch_5_merge.df <- merge_within_epoch(
  epoch = 5,
  main = MAPfreeze.list$epoch_5$data$main,
  # abp = MAPfreeze.list$epoch_5$data$abp.static,
  # biomarkers = MAPfreeze.list$epoch_5$data$biomarkers,
  auto3T = MAPfreeze.list$epoch_5$data$auto3T,
  # auto3TBH = MAPfreeze.list$epoch_5$data$auto3T.bh,
  man3T = MAPfreeze.list$epoch_5$data$man3T,
  # man3TBH = MAPfreeze.list$epoch_5$data$man3T.bh,
  qmass = MAPfreeze.list$epoch_5$data$cardiac.mri,
  # addendum = MAPfreeze.list$epoch_5$data$addendum,
  csf = MAPfreeze.list$epoch_5$data$csf
  # srt = MAPfreeze.list$epoch_5$data$srt.static
)
```

## Merge across all Epochs {.tabset .tabset-fade .tabset-pills}

Now that we have created a single data frame for each available epoch, we will investigate any differences between the epochs and stack the data frames into one longitudinal data set.

### Compare and Stack: Epoch 2 with Epoch 1

Here we refer to the Epoch 2 data as "new" and the previous epochs (Epoch 1) as "old."

```{r compare-epoch1-epoch2}
compare_variables(new_data = epoch_2_merge.df, old_data = epoch_1_merge.df)
compare_ids(new_data = epoch_2_merge.df, old_data = epoch_1_merge.df)
factors_to_unify.var <- compare_factors(new_data = epoch_2_merge.df, old_data = epoch_1_merge.df) %>% pull(Variable)
```

```{r}
refactored_var.list <- NULL

for (var.i in factors_to_unify.var) {
  refactored_var.list <- forcats::fct_unify(list(epoch_1_merge.df[[var.i]], epoch_2_merge.df[[var.i]]))
  epoch_1_merge.df[[var.i]] <- refactored_var.list[[1]]
  epoch_2_merge.df[[var.i]] <- refactored_var.list[[2]]
  refactored_var.list <- NULL
}

cat(paste0(
  "The differing levels of the following factor variables were unified prior to stacking: ",
  paste0(factors_to_unify.var, collapse = ", "),
  ".\n"
))

factors_to_unify.var <- NULL
```

```{r coerce-stack-epoch1-epoch2}
merged.df <- coerce_and_stack(new_data = epoch_2_merge.df, old_data = epoch_1_merge.df)
```

### Compare and Stack: Epoch 3 with Epochs 1 and 2

Here we refer to the Epoch 3 data as "new" and the previous epochs (Epochs 1 and 2) as "old."

```{r compare-epoch12-epoch3}
compare_variables(new_data = epoch_3_merge.df, old_data = merged.df)
compare_ids(new_data = epoch_3_merge.df, old_data = merged.df)
factors_to_unify.var <- compare_factors(new_data = epoch_3_merge.df, old_data = merged.df) %>% pull(Variable)
```

```{r}
for (var.i in factors_to_unify.var) {
  refactored_var.list <- forcats::fct_unify(list(merged.df[[var.i]], epoch_3_merge.df[[var.i]]))
  merged.df[[var.i]] <- refactored_var.list[[1]]
  epoch_3_merge.df[[var.i]] <- refactored_var.list[[2]]
  refactored_var.list <- NULL
}

cat(paste0(
  "After manually checking, the differing levels of the following factor variables were unified prior to stacking: ",
  paste0(factors_to_unify.var, collapse = ", "),
  ".\n"
))

factors_to_unify.var <- NULL
```

```{r coerce-stack-epoch12-epoch3}
merged.df <- coerce_and_stack(new_data = epoch_3_merge.df, old_data = merged.df)
```

### Compare and Stack: Epoch 4 with Epochs 1, 2, and 3

Here we refer to the Epoch 4 data as "new" and the previous epochs (Epochs 1, 2, and 3) as "old."

```{r compare-epoch123-epoch4}
compare_variables(new_data = epoch_4_merge.df, old_data = merged.df)
compare_ids(new_data = epoch_4_merge.df, old_data = merged.df)
factors_to_unify.var <- compare_factors(new_data = epoch_4_merge.df, old_data = merged.df) %>% pull(Variable)
```

```{r}
for (var.i in factors_to_unify.var) {
  refactored_var.list <- forcats::fct_unify(list(merged.df[[var.i]], epoch_4_merge.df[[var.i]]))
  merged.df[[var.i]] <- refactored_var.list[[1]]
  epoch_4_merge.df[[var.i]] <- refactored_var.list[[2]]
}

cat(paste0(
  "After manually checking, the differing levels of the following factor variables were unified prior to stacking: ",
  paste0(factors_to_unify.var, collapse = ", "),
  ".\n"
))

factors_to_unify.var <- NULL
```

```{r coerce-stack-epoch123-epoch4}
merged.df <- coerce_and_stack(new_data = epoch_4_merge.df, old_data = merged.df)

merged.df[, Cs(actigraph_day4_mins, actigraph_day6_mins)] <- sapply(merged.df[, Cs(actigraph_day4_mins, actigraph_day6_mins)], as.numeric)
```

### Compare and Stack: Epoch 5 with Epochs 1, 2, 3, and 4

Here we refer to the Epoch 5 data as "new" and the previous epochs (Epochs 1, 2, 3, and 4) as "old."

```{r compare-epoch1234-epoch5}
compare_variables(new_data = epoch_5_merge.df, old_data = merged.df)
compare_ids(new_data = epoch_5_merge.df, old_data = merged.df)
factors_to_unify.var <- compare_factors(new_data = epoch_5_merge.df, old_data = merged.df) %>% pull(Variable)
```

```{r}
for (var.i in factors_to_unify.var) {
  refactored_var.list <- forcats::fct_unify(list(merged.df[[var.i]], epoch_5_merge.df[[var.i]]))
  merged.df[[var.i]] <- refactored_var.list[[1]]
  epoch_5_merge.df[[var.i]] <- refactored_var.list[[2]]
}

cat(paste0(
  "After manually checking, the differing levels of the following factor variables were unified prior to stacking: ",
  paste0(factors_to_unify.var, collapse = ", "),
  ".\n"
))

factors_to_unify.var <- NULL
```

```{r coerce-stack-epoch1234-epoch5}
merged.df <- coerce_and_stack(new_data = epoch_5_merge.df, old_data = merged.df)

#merged.df[, Cs(actigraph_day4_mins, actigraph_day6_mins)] <- sapply(merged.df[, Cs(actigraph_day4_mins, actigraph_day6_mins)], as.numeric)
```

## Merge Additional Epoch-Independent Data {.tabset .tabset-fade .tabset-pills}

### Add APOE Genetic Data

```{r}
apoe.df <- MAPfreeze.list$epoch_0$data$apoe %>%
  select(
    map_id, rs429358_allele, rs7412_allele, alleles
  ) %>%
  format_id()

check_shared_vars(merged.df, apoe.df, 'map_id')

merged.df %<>% left_join(
  apoe.df,
  by = "map_id"
) 
```

### Add ABPM Consent Data

```{r}
tracking.static.df <- MAPfreeze.list$epoch_0$data$tracking.static %>%
  select(
    map_id, elig_visit_consent_abpm, elig_visit_consent_lp, elig_visit_consent_lp_ineligible
  ) %>%
  format_id(.) %>%
  mutate_if(
    ~ any(class(.) %in% c("numeric", "integer", "character")),
    ~ missing_to_na(., equal.val = c(-6666, -7777, -8888, -9999), mod.val = -1111, restrict.sign = TRUE)
  )

check_shared_vars(merged.df, tracking.static.df, 'map_id')

merged.df %<>% left_join(
  tracking.static.df,
  by = "map_id"
) %>% 
  mutate(
    abp_consent = ifelse(epoch == 1, elig_visit_consent_abpm, NA),
    abp_consent_factor = factor(abp_consent, levels = c(0, 1), labels = c("No", "Yes")) 
  )
```

### Add Eligibility Data

```{r}
eligibility.df <- MAPfreeze.list$epoch_0$data$eligibility %>%
  format_id() %>%
  process_eligibility()

check_shared_vars(merged.df, eligibility.df, 'map_id')

merged.df %<>% left_join(
  eligibility.df,
  by = "map_id"
) 
```

### Add Polygenetic Risk Score Data

```{r}
polygenetic.df <- MAPfreeze.list$epoch_0$data$polygenetic.static
names(polygenetic.df) <- tolower(names(polygenetic.df))
names(polygenetic.df)[1] <- "map_id"

check_shared_vars(merged.df, polygenetic.df, 'map_id')

merged.df %<>% left_join(
  polygenetic.df,
  by = "map_id"
) 
```

# Manual Invalidation: Pre-Derivation

MAP ID 163 has a set of variables to be invalidated due to the presence of a brain cyst.

```{r}
map_163_invalid_variables.vec <- readxl::read_excel(map_163_invalidation.file) %>%
  pull(., 1)

merged.df[merged.df$map_id == "163", map_163_invalid_variables.vec] <- NA
```

MAP IDs 028, 033, 131, 169, 176, 201 require color-related variables to be invalidated due to color blindness.

```{r}
merged.df <- call_function("invalidate_color_blind", merged.df)
```

Any infinite values that result from dividing by zero in REDCap formulas will be set to missing.

```{r}
is.na(merged.df) <- sapply(merged.df, is.infinite)
```

# Format Variable Names and Apply Labels to each Variable

```{r}
merged.df <- format_names(merged.df)
```

```{r}
nolabel <- names(merged.df)[lapply(merged.df, function(x) label(x)) == ""]

format_metadata <- function(data) {
  data %>%
    dplyr::select(
      one_of(
        c("field_name", "form_name", "field_type", "field_label", "select_choices_or_calculations")
      )
    ) %>%
    dplyr::mutate(
     field_name = gsub("\\_", "\\.", field_name)
    )
}

labels.elig <- format_metadata(MAPfreeze.list[["epoch_0"]][["metadata"]][["eligibility"]]) %>% 
  mutate(
    epoch = 0
  ) %>%
  mutate(
    field_name = paste0(field_name, ".elig")
  )

labels.apoe <- format_metadata(MAPfreeze.list[["epoch_0"]][["metadata"]][["apoe"]]) %>% 
  mutate(
    epoch = 0
  )

labels.1 <- lapply(MAPfreeze.list[["epoch_1"]][["metadata"]][c("main", "cardiac.mri", "man3T", "man3T.bh", "auto3T", "auto3T.bh", "csf", "biomarkers", "addendum")], format_metadata) %>% 
  bind_rows() %>% 
  mutate(epoch = 1)

labels.2 <- lapply(MAPfreeze.list[["epoch_2"]][["metadata"]], format_metadata) %>%
  bind_rows() %>%
  mutate(epoch = 2)

labels.3 <- lapply(MAPfreeze.list[["epoch_3"]][["metadata"]], format_metadata) %>%
  bind_rows() %>%
  mutate(epoch = 3)

labels.4 <- lapply(MAPfreeze.list[["epoch_4"]][["metadata"]], format_metadata) %>%
  bind_rows() %>%
  mutate(epoch = 4)

labels.5 <- lapply(MAPfreeze.list[["epoch_5"]][["metadata"]], format_metadata) %>%
  bind_rows() %>%
  mutate(epoch = 5)

labels.all <- dplyr::bind_rows(labels.elig, labels.apoe, labels.1, labels.2, labels.3, labels.4, labels.5) %>% 
  dplyr::distinct(field_name, field_label, .keep_all = TRUE)

duplicated.names <- labels.all$field_name[duplicated(labels.all$field_name)]

variables_with_contradicting_labels_on_REDCap.df <- 
  labels.all[labels.all$field_name %in% duplicated.names, Hmisc::Cs(field_name, field_label, form_name, epoch)] %>% 
    arrange(field_name, epoch)

readr::write_csv(
  x = variables_with_contradicting_labels_on_REDCap.df,
  path = file.path(
    merge.report.dir,
    paste0("variables_with_contradicting_labels_on_REDCap.csv")
  )
)

labels.all %<>%
  group_by(field_name) %>%
  arrange(field_name, epoch) %>%
  select(field_name, field_label, epoch) %>%
  slice(1) %>%
  ungroup()

labels.bHold.df <- labels.all %>%
  filter(
    field_name %in% gsub("bHold.", "", names(merged.df)[names(merged.df) %in% paste0("bHold.", labels.all$field_name)])
  ) %>%
  select(
    Cs(field_name, field_label, epoch)
  ) %>%
  mutate(
    field_name = paste0("bHold.", field_name)
  )

labels.factor.df <- labels.all %>%
  filter(
    field_name %in% gsub(".factor", "", names(merged.df)[names(merged.df) %in% paste0(labels.all$field_name, ".factor")])
  ) %>%
  select(
    Cs(field_name, field_label, epoch)
  ) %>%
  mutate(
    field_name = paste0(field_name, ".factor")
  )

labels.bHold.factor.df <- labels.all %>%
  filter(
    field_name %in% gsub("bHold\\.|\\.factor", "", names(merged.df)[names(merged.df) %in% paste0("bHold.", labels.all$field_name, ".factor")])
  ) %>%
  select(
    Cs(field_name, field_label, epoch)
  ) %>%
  mutate(
    field_name = paste0("bHold.", field_name, ".factor")
  )

labels.elig.df <- labels.all %>%
  filter(
    field_name %in% gsub(".elig", "", names(merged.df)[names(merged.df) %in% paste0(labels.all$field_name, ".elig")])
  ) %>%
  select(
    Cs(field_name, field_label, epoch)
  ) %>%
  mutate(
    field_name = paste0(field_name, ".elig")
  )

labels.elig.factor.df <- labels.all %>%
  filter(
    field_name %in% gsub(".factor.elig", "", names(merged.df)[names(merged.df) %in% paste0(labels.all$field_name, ".factor.elig")])
  ) %>%
  select(
    Cs(field_name, field_label, epoch)
  ) %>%
  mutate(
    field_name = paste0(field_name, ".factor.elig")
  )

labels.df <- bind_rows(labels.all, labels.bHold.df, labels.factor.df, labels.bHold.factor.df, labels.elig.df, labels.elig.factor.df) %>%
  filter(
    field_name %in% names(merged.df)
  )

variables_without_labels.df <- data.frame(
  variable = names(merged.df)[names(merged.df) %nin% labels.df$field_name], 
  stringsAsFactors = FALSE
)

readr::write_csv(
  x = variables_without_labels.df,
  path = file.path(
    merge.report.dir,
    paste0("variables_without_labels_pre-derivation.csv")
  )
)

for (var.i in labels.df$field_name) {
  Hmisc::label(merged.df[, var.i]) <- pull(labels.df[labels.df$field_name == var.i, "field_label"])[1]
}

label(merged.df$epoch) <- "Epoch"
```

The following variables do not have labels (this list excludes variables with the words 'complete', '...', or 'score'):

```{r}
print(data.frame(variables = sort(grep("complete|\\.\\.\\.|score", names(merged.df)[lapply(merged.df, function(x) label(x)) == ""], v= T, invert = T))))
```

# Derivation of New Variables {.tabset .tabset-fade .tabset-pills}

## Dates

Derive, label, and add date variables to the merged data set.

```{r derive-dates}
merged.df <- call_function("derive_dates", merged.df)
```

## Demographics

Derive, label, and add demographic variables to the merged data set.

```{r derive-demographic}
merged.df <- call_function("derive_demographics", merged.df)
```

## ApoE

Derive, label, and add ApoE variables to the merged data set.

```{r derive-apoe}
merged.df <- call_function("derive_apoe", merged.df)
```

## Medication and Surgery

Derive, label, and add medication and surgery variables to the merged data set.

```{r derive-medicationsAndSurgery}
merged.df <- call_function("derive_medication_surgery", merged.df,
  diabetes.file                    = MAPfreeze.list$epoch_0$data$diabetes.static,
  cholesterol.file                 = MAPfreeze.list$epoch_0$data$cholesterol.static,
  afib.file                        = MAPfreeze.list$epoch_0$data$afib.static,
  afib_surgery.file                = MAPfreeze.list$epoch_0$data$afibsurg.static,
  AH_beta_blocker.file             = MAPfreeze.list$epoch_0$data$antihypBetaBlocker.static,
  AH_beta_blocker_if_not_drop.file = MAPfreeze.list$epoch_0$data$antihypBetaBlockerIfNotDrop.static,
  AH_ace_inhibitor.file            = MAPfreeze.list$epoch_0$data$antihypACEInhib.static,
  AH_arb.file                      = MAPfreeze.list$epoch_0$data$antihypARB.static,
  AH_ccb.file                      = MAPfreeze.list$epoch_0$data$antihypCCB.static,
  AH_ksd.file                      = MAPfreeze.list$epoch_0$data$antihypKSD.static,
  AH_other.file                    = MAPfreeze.list$epoch_0$data$antihypOther.static
)
```

## Blood Values

Derive, convert, label, and add blood variables to the merged data set.

```{r derive-bloodConversion}
merged.df <- call_function("derive_blood", merged.df)
```

## Medical History

Derive, label, and add medical history variables to the merged data set.

```{r derive-medhxEtc}
cmr.findings.rhythm.afib <- c(
  "atrial fibrillation"
)

cmr.findings.rhythm.normal <- c(
  "sinus"                                                ,
  "sinus with frequent pvcs"                             ,
  "sinus with frequent pvcs,"                            ,
  "sinus with atrial bigeminy"                           ,
  "sinus with frequent pacs"                             ,
  "sinus arrhythmia"                                     ,
  "sinus with intermittent second degree av block"       ,
  "sinus with frequent pvcs (often in trigeminy)"        ,
  "small"                                                ,
  "sinus with ivcd"                                      ,
  "sinus with frequent pvcs often in a trigeminy pattern"
)

merged.df <- call_function("derive_medical_hx", merged.df)
```

## Cardiac MRI

Derive, label, and add CMR variables to the merged data set.

```{r derive-cmr}
merged.df <- call_function("derive_cardiac_mri", merged.df)
```

## Thigh

Derive, label, and add thigh variables to the merged data set.

```{r derive-thigh}
merged.df <- call_function("derive_thigh", merged.df)
```

## Cardiac Structure

Derive, label, and add cardiac structure variables to the merged data set.

```{r derive-cardiacStructure}
merged.df <- call_function("derive_cardiac_structure", merged.df)
```

## ABP QC

Derive, label, and add ABP QC variables to the merged data set.

```{r derive-abpqc}
merged.df <- call_function("derive_abp_qc", merged.df)
```

## FSRP

Derive, label, and add FSRP variables to the merged data set.

```{r derive-fsrp}
merged.df <- call_function("derive_fsrp", merged.df)
```

## Cognitive Complaint, FCADL, and FAQ

Derive, label, and add cognitive complaint, FCADL, and FAQ variables to the merged data set.

```{r derive-cognitiveComplaint}
merged.df <- call_function("derive_cognitive_complaint", merged.df)
```

## Neuropsychological Variables

Derive, label, and add neuropsychological variables to the merged data set.

```{r derive-neuropsych}
merged.df <- call_function("derive_neuropsych", merged.df)
```

## MLTA and CHAMPS

Derive, convert, label, and add MLTA and CHAMPS variables to the merged data set.

```{r derive-mltaChamps}
merged.df <- call_function("derive_mlta_champs", merged.df)
```

## Depression

Derive, label, and add depression variables to the merged data set.

```{r derive-depression}
merged.df <- call_function("derive_depression", merged.df)
```

## Biomarkers

Derive, label, and add biomarker variables to the merged data set.

```{r derive-biomarkers}
merged.df <- call_function("derive_biomarkers", merged.df)
```

## Informant Information

Derive, label, and add informant information variables to the merged data set.

```{r derive-informatInfo}
merged.df <- call_function("derive_informant_info", merged.df)
```

## Diagnosis and Staging

Derive, label, and add diagnosis and staging variables to the merged data set.

```{r derive-diagnosisAndStaging}
merged.df <- call_function("derive_diagnosis_staging", merged.df)
```

## PSQI

Derive, label, and add PSQI variables to the merged data set.

```{r derive-psqi}
merged.df <- call_function("derive_psqi", merged.df)
```

## Frailty

Derive, label, and add frailty variables to the merged data set.

```{r derive-frailty}
merged.df <- call_function("derive_frailty", merged.df)
```

## Food Scan

Derive, convert, label, and add food scan variables to the merged data set.

```{r derive-foodScan}
merged.df <- call_function("derive_food_scan", merged.df)
```

## PVLT

Derive, label, and add PVLT variables to the merged data set.

```{r derive-pvlt}
merged.df <- call_function("derive_pvlt", merged.df)
```

## CDR Conversion

Derive, label, and add CDR conversion variables to the merged data set.

```{r derive-cdr-conversion}
merged.df <- call_function("derive_cdr_conversion", merged.df)
```

```{r}
class(merged.df) <- "data.frame"
```

## Circle of Willis (CoW) Variants

```{r derive-cow-variants}
merged.df <- call_function("derive_cow_variants", merged.df)
```

```{r}
class(merged.df) <- "data.frame"
```

# Manual Invalidation: Post-Derivation

In this section, we will invalidate certain derived variables for specified individuals as requested by VMAC.

```{r invalidate-derived-np}
merged.df <- call_function("invalidate_derived_neuropsych_items", merged.df)
```

# Repeating Baseline Variables in Each Epoch

```{r repeatBaseline}
enrollment_vars <- Cs(
  dob,
  education,
  sex.factor,
  race.factor,
  ethnicity.factor,
  raceethnicity.factor,
  usa.born.factor,
  lang.prim.factor,
  alleles,
  alleles.factor,
  rs429358.allele,
  rs7412.allele,
  apoe2pos,
  apoe4pos,
  apoe2count,
  apoe4count,
  apoe2pos.factor,
  apoe4pos.factor,
  pgc.score,
  pgc.noapoe.score
)

baseline_vars <- Cs( # will have ".base" appended to the end
  diagnosis.factor,
  mci.stage.factor, 
  albert.mci.stage.factor, 
  age
)

to_repeat.df <- merged.df[merged.df$epoch %in% 1, c('map.id', enrollment_vars, baseline_vars)]

for (var.i in baseline_vars) {
  label(to_repeat.df[[var.i]]) <- paste0(label(to_repeat.df[[var.i]]), ", from Enrollment")
}

names(to_repeat.df) <- c('map.id', enrollment_vars, paste0(baseline_vars, ".base"))

merged.df <- merged.df[, names(merged.df)[!names(merged.df) %in% enrollment_vars]] %>% 
  left_join(
    to_repeat.df,
    by = "map.id"
  )

cat("The following variables were added to each epoch for each participant:\n")
print(data.frame(`New Variables` = setdiff(names(to_repeat.df), "map.id")))
```

# Manual Modification of Factor Levels

## Re-ordering Levels in `diagnosis.factor` and `diagnosis.factor.base`

```{r reorder-dx-level}
merged.df <- merged.df %>%
  mutate(
    diagnosis.factor.base = forcats::fct_relevel(diagnosis.factor.base, "Normal", "Ambiguous At Risk", "MCI", "Dementia"),
    diagnosis.factor = forcats::fct_relevel(diagnosis.factor, "Normal", "Ambiguous At Risk", "MCI", "Dementia")
  )
```

## Setting Reference to "No" for Yes/No Variables

```{r ref-level-no}
levels.list <- purrr::map(merged.df, levels)
factor_var.list <- levels.list[!purrr::map_lgl(levels.list, is.null)]

reference_yes.list <- factor_var.list[purrr::map(factor_var.list, 1) == "Yes"]

reference_yes.var <- names(reference_yes.list)

for (var.i in reference_yes.var) {
  merged.df[[var.i]] <- relevel(merged.df[[var.i]], "No")
}
```

Reference level has been set to 'No' for the following Yes/No variables:

```{r print-refno-df}
print(data.frame(variables = reference_yes.var))
```

# Adding Memory and Executive Function Composite Scores

These scores were provided to us in two RDS files dated June 20, 2019 by Timothy Hohman after calculating them in MPlus.

```{r mem-ef-composite}
mem.composite.df <- MAPfreeze.list$epoch_0$data$np.memory.composite.static %>%
  rename(np.memory.composite = memory.composite) %>%
  mutate(
    epoch = as.numeric(epoch)
  )

ef.composite.df <- MAPfreeze.list$epoch_0$data$np.executive.composite.static %>%
  rename(np.executive.composite = executive.composite) %>%
  mutate(
    epoch = as.numeric(epoch)
  )

label(mem.composite.df$map.id) <- label(ef.composite.df$map.id) <- "MAP ID"
label(mem.composite.df$epoch) <- label(ef.composite.df$epoch) <- "Epoch"

merged.df %<>% left_join(
  mem.composite.df,
  by = c("map.id", "epoch")
)

merged.df %<>% left_join(
  ef.composite.df,
  by = c("map.id", "epoch")
)

label(merged.df$np.memory.composite) <- 'Memory Composite'
label(merged.df$np.executive.composite) <- 'EF Composite'
label(merged.df$diagnosis.factor) <- label(merged.df$diagnosis)
label(merged.df$diagnosis.factor.base) <- paste0(label(merged.df$diagnosis), ", from Enrollment")
```

# Separating Breath Hold and Face Mask Data Sets

In this step, we create separate data sets for the breath hold and face mask groups.

```{r separateBHfromFM}
bHold.var <- grep("^bHold\\.", names(merged.df), v = T)
bHold.index <- match(bHold.var, names(merged.df))

regnames <- gsub("^bHold\\.", "", bHold.var)
bHoldnamesWithCounterparts <- bHold.var[regnames %in% names(merged.df)]

merged.fm.df <- merged.df[, -bHold.index]

merged.bh.df <- merged.df
merged.bh.df[merged.df$epoch == 1 & as.numeric(merged.df$map.id) <= 25, regnames] <- 
  merged.bh.df[merged.df$epoch == 1 & as.numeric(merged.df$map.id) <= 25, bHoldnamesWithCounterparts]
merged.bh.df <- merged.bh.df[, -bHold.index]
```

# Derivation of Variables after Separation of Breath Hold and Face Mask Data Sets

## Automated 3T

Derive, label, and add automated 3T variables to the merged data set. ASL reactivity variables are also calculated in this step.

```{r derive-auto3T}
merged.bh.df <- call_function("derive_automated_3T", merged.bh.df)
merged.fm.df <- call_function("derive_automated_3T", merged.fm.df)
```

## Manual 3T

Derive, label, and add manual 3T variables to the merged data set.

```{r derive-man3T}
merged.bh.df <- call_function("derive_manual_3T", merged.bh.df)
merged.fm.df <- call_function("derive_manual_3T", merged.fm.df)
```

## AD Signature

Derive, label, and add AD signature McEvoy and Schwarz variables to the merged data set.

```{r derive-AD-sig}
merged.bh.df <- derive_AD_signature(merged.bh.df)
merged.fm.df <- derive_AD_signature(merged.fm.df)
```

# Saving the Final Data

We will save the Face Mask and Breath Hold data sets to the `box/VMAC BIOSTAT/DATA/MAP/mergedData` directory as RDS and CSV files.

```{r}
class(merged.bh.df) <- "data.frame"
class(merged.fm.df) <- "data.frame"
```

```{r save-data}
saveRDS(merged.fm.df, file = paste0(data.merge.fm.file, ".rds"))
write.csv(merged.fm.df, file = paste0(data.merge.fm.file, ".csv"), row.names = FALSE)

saveRDS(merged.bh.df, file = paste0(data.merge.bh.file, ".rds"))
write.csv(merged.bh.df, file = paste0(data.merge.bh.file, ".csv"), row.names = FALSE)
```

# Current vs Previous Data Comparison {.tabset .tabset-fade .tabset-pills}

This section highlights changes between the current and previous breath hold data sets. To reduce the size of the output, variables matching the following criteria will be excluded from the comparison:

- variable name starts with "med" and is followed by one or more numbers
- variable name includes "notes"
- variable name starts with "entry"
- variable name contains "famhx" and is followed by one or more numbers
- variable name ends with "complete"
- all values are missing

For sake of simplicity, we will code integer-type variables as numeric and factor-type variables as character prior to comparison.

```{r diff-setup}
if (is.null(last.data.merge.bh.file)) {
  warning("Please specify the download and merge dates for the previous data set.\n")
} else {
  prev.bh.df <- readRDS(paste0(last.data.merge.bh.file, ".rds")) %>% clear_labels()
  merged.bh.df <- clear_labels(merged.bh.df)

  all.var <- union(names(merged.bh.df), names(prev.bh.df))
  vars_to_exclude <- unique(c(
    grep("\\.{3}", all.var, v = T),
    grep("^med\\d+", all.var, v = T), 
    grep("notes", all.var, v = T), 
    grep("^entry", all.var, v = T), 
    grep("famhx\\d+", all.var, v = T),
    grep("complete$", all.var, v = T)
    ))
  
  all.var <- all.var[!all.var %in% vars_to_exclude]
}

current.all.var <- all.var[all.var %in% names(merged.bh.df)]
prev.all.var <- all.var[all.var %in% names(prev.bh.df)]
```

## Epoch 1

```{r diff-e1}
current.e1.df <- merged.bh.df %>%
  filter(
    epoch %in% 1
  ) %>%
  mutate(
    epoch = as.integer(epoch)
  ) %>%
  select(
    one_of(c('map.id', 'epoch', current.all.var))
  ) %>%
  select_if(~ !all(is.na(.))) %>%
  droplevels.data.frame()

prev.e1.df <- prev.bh.df %>%
  filter(
    epoch %in% 1
  ) %>%
  mutate(
    epoch = as.integer(epoch)
  ) %>%
  select(
    one_of(c('map.id', 'epoch', prev.all.var))
  ) %>%
  select_if(~ !all(is.na(.))) %>%
  droplevels.data.frame()

e1.comparison <- comparedf(
  current.e1.df, prev.e1.df, 
  by = c("map.id", "epoch"),
  int.as.num = TRUE,
  factor.as.char = TRUE
)

e1.diff <- diffs(e1.comparison)

readr::write_csv(
  x = e1.diff,
  path = file.path(
    merge.report.dir,
    paste0("e1_diff.csv")
  )
)

diffs(e1.comparison, by.var = TRUE) %>%
  filter(n > 0 | NAs > 0)
```

## Epoch 2

```{r diff-e2}
current.e2.df <- merged.bh.df %>%
  filter(
    epoch %in% 2
  ) %>%
  mutate(
    epoch = as.integer(epoch)
  ) %>%
  select(
    one_of(c('map.id', 'epoch', current.all.var))
  ) %>%
  select_if(~ !all(is.na(.))) %>%
  droplevels.data.frame()

prev.e2.df <- prev.bh.df %>%
  filter(
    epoch %in% 2
  ) %>%
  mutate(
    epoch = as.integer(epoch)
  ) %>%
  select(
    one_of(c('map.id', 'epoch', prev.all.var))
  ) %>%
  select_if(~ !all(is.na(.))) %>%
  droplevels.data.frame()

e2.comparison <- comparedf(
  current.e2.df, prev.e2.df, 
  by = c("map.id", "epoch"),
  int.as.num = TRUE,
  factor.as.char = TRUE
)

e2.diff <- diffs(e2.comparison)

readr::write_csv(
  x = e2.diff,
  path = file.path(
    merge.report.dir,
    paste0("e2_diff.csv")
  )
)
diffs(e2.comparison, by.var = TRUE) %>%
  filter(n > 0 | NAs > 0)
```

## Epoch 3

```{r diff-e3}
current.e3.df <- merged.bh.df %>%
  filter(
    epoch %in% 3
  ) %>%
  mutate(
    epoch = as.integer(epoch)
  ) %>%
  select(
    one_of(c('map.id', 'epoch', current.all.var))
  ) %>%
  select_if(~ !all(is.na(.))) %>%
  droplevels.data.frame()

prev.e3.df <- prev.bh.df %>%
  filter(
    epoch %in% 3
  ) %>%
  mutate(
    epoch = as.integer(epoch)
  ) %>%
  select(
    one_of(c('map.id', 'epoch', prev.all.var))
  ) %>%
  select_if(~ !all(is.na(.))) %>%
  droplevels.data.frame()

e3.comparison <- comparedf(
  current.e3.df, prev.e3.df, 
  by = c("map.id", "epoch"),
  int.as.num = TRUE,
  factor.as.char = TRUE
)

e3.diff <- diffs(e3.comparison)

readr::write_csv(
  x = e3.diff,
  path = file.path(
    merge.report.dir,
    paste0("e3_diff.csv")
  )
)

diffs(e3.comparison, by.var = TRUE) %>%
  filter(n > 0 | NAs > 0)
```

## Epoch 4

```{r diff-e4}
current.e4.df <- merged.bh.df %>%
  filter(
    epoch %in% 4
  ) %>%
  mutate(
    epoch = as.integer(epoch)
  ) %>%
  select(
    one_of(c('map.id', 'epoch', current.all.var))
  ) %>%
  select_if(~ !all(is.na(.))) %>%
  droplevels.data.frame()

prev.e4.df <- prev.bh.df %>%
  filter(
    epoch %in% 4
  ) %>%
  mutate(
    epoch = as.integer(epoch)
  ) %>%
  select(
    one_of(c('map.id', 'epoch', prev.all.var))
  ) %>%
  select_if(~ !all(is.na(.))) %>%
  droplevels.data.frame()

e4.comparison <- comparedf(
  current.e4.df, prev.e4.df, 
  by = c("map.id", "epoch"),
  int.as.num = TRUE,
  factor.as.char = TRUE
)

e4.diff <- diffs(e4.comparison)

readr::write_csv(
  x = e4.diff,
  path = file.path(
    merge.report.dir,
    paste0("e4_diff.csv")
  )
)

diffs(e4.comparison, by.var = TRUE) %>%
  filter(n > 0 | NAs > 0)
```

## Epoch 5

```{r diff-e5, eval = FALSE}
current.e5.df <- merged.bh.df %>%
  filter(
    epoch %in% 5
  ) %>%
  mutate(
    epoch = as.integer(epoch)
  ) %>%
  select(
    one_of(c('map.id', 'epoch', current.all.var))
  ) %>%
  select_if(~ !all(is.na(.))) %>%
  droplevels.data.frame()

prev.e5.df <- prev.bh.df %>%
  filter(
    epoch %in% 5
  ) %>%
  mutate(
    epoch = as.integer(epoch)
  ) %>%
  select(
    one_of(c('map.id', 'epoch', prev.all.var))
  ) %>%
  select_if(~ !all(is.na(.))) %>%
  droplevels.data.frame()

e5.comparison <- comparedf(
  current.e5.df, prev.e5.df, 
  by = c("map.id", "epoch"),
  int.as.num = TRUE,
  factor.as.char = TRUE
)

e5.diff <- diffs(e5.comparison)

readr::write_csv(
  x = e5.diff,
  path = file.path(
    merge.report.dir,
    paste0("e5_diff.csv")
  )
)

diffs(e5.comparison, by.var = TRUE) %>%
  filter(n > 0 | NAs > 0)
```

# Session Info

```{r}
sessionInfo()
```
