---
title: "VMAP Data Merge"
subtitle: "Face Mask Data"
author: '[Omair A. Khan, MAS, PStat](mailto:omair.a.khan@vumc.org)'
date: "Data Freeze Date: `r full.freeze.date` | Data Merge Date: `r full.modified.date`"
output:
  html_notebook:
    code_folding: hide
    theme: lumen
    number_sections: true
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
---

<style type="text/css">
 #TOC{
   position:fixed;
   top:0;
   // left:0;
   right:0;
   margin: 32px 20px 20px 20px;
   z-index: 9;
   // display:none;
  }
  #toc-toggle{
    position:fixed;
    top:0;
    // left:0;
    right:0;
    margin: 5px 20px 5px 20px;
  }
  .col-md-3{
    width: 0%;
  }
  .col-md-9{
    width: 100%;
  }
  div.container-fluid.main-container{
    max-width:none;
    margin-left:0px;
    margin-right:none;
  }
  div.plot-container{
    margin-left:50px;
    margin-bottom:20px;
  }
  h1.title{
    max-width:950px;
  }
  li.tocify-item{
    text-indent:0px;
  }
  #toc-toggle{
    z-index:9;
  }
  .tocify-subheader, .tocify-item, .tocify, .list-group-item{
  font-size:12pt;
  }
</style>

<button id="toc-toggle" type="button" class="btn btn-default btn-xs code-folding-btn pull-right collapsed" onclick="toggletoc()"><span>Table of Contents (click to hide/show)</span></button>

<script>
function toggletoc(){
$("#TOC").toggle();
}x    
</script>

# Notes

1. Important changes or specific notes to the VMAC team will go here.

```{r setup, echo = TRUE, results = 'hide'}
# define important directories
## base directories
box.dir  <- file.path("~", "Box Sync")
vmac.dir <- file.path(box.dir, "VMAC BIOSTAT")
## data directories
data.dir <- file.path(vmac.dir, "DATA", "MAP")

##%######################################################%##
####                modifiable settings                 ####
# quarterly scheduled merge, TRUE; off-cycle merge, FALSE
quarterly.download <- TRUE
# modify one of these variables to download data or specify a specific raw data file to use for merging
download.data <- FALSE
data.freeze.date <- yyyymmdd # in {yyyymmdd} format
# modify both of these variables to specify a specific data merge file to compare the new one with
last.data.download.date <- yyyymmdd # in {yyyymmdd} format
last.data.merge.date <- yyyymmdd # in {yyyymmdd} format

map_163_invalidation.file <- file.path(data.dir, "Documentation", "MAP163_variablesunusable.xlsx")
####                                                    ####
##%######################################################%##

packages <- Hmisc::Cs(
  tidyverse,
  knitr,
  lubridate,
  magrittr,
  daff,
  Hmisc,
  formattable,
  REDCapR,
  arsenal,
  fs,
  beepr
)

rVMAP::load_pkg(packages)

devtools::load_all("~/dev/rVMAP")

# set timezone
Sys.setenv(TZ = 'US/Central')

# Hmisc options
options(
  prType = 'html', 
  grType = 'plotly',
  digits = 6,
  contrasts = c("contr.treatment", "contr.treatment")
)

# define additional important directories
## data directories

data.raw.dir <- file.path(data.dir, "rawData")
data.merge.dir <- file.path(data.dir, 'mergedData')
```

```{r}
if (download.data == TRUE) {
  # specify data freeze date
  data.freeze.date <- format(Sys.time(), "%Y%m%d")
  # load raw data
  MAPfreeze.list <- data_freeze(quarterly.download = quarterly.download, save = TRUE)
} else if (download.data == FALSE & is.null(data.freeze.date)) {
  # get path to most recent REDCap freeze
  data.freeze.file <- file.info(
    list.files(
      path = data.raw.dir, 
      pattern = "MAPfreeze_\\d{8}.rds",
      full.names = T
    )
  ) %>%
    tibble::rownames_to_column(., var = "path") %>%
    arrange(desc(mtime)) %>% 
    filter(row_number() == 1) %>%
    pull(1)
  # extract data freeze date
  data.freeze.date <- stringr::str_extract(data.freeze.file, "\\d{8}")
  # load raw data
  MAPfreeze.list <- readRDS(data.freeze.file)
} else if (download.data == FALSE & !is.null(data.freeze.date)) {
  # data freeze date is user specified
  # load raw data
  MAPfreeze.list <- readRDS(
    file.path(
      data.raw.dir,
      paste0(
        "MAPfreeze_", 
        data.freeze.date, 
        ".rds"
      )
    )
  )
} else {
  stop("Either `download.data` or `data.freeze.date` must be specified as TRUE or FALSE and a 8 digit yyyymmdd, respectively.")
}

# define paths for saving current merged files
data.merge.date <- format(Sys.time(), "%Y%m%d")
current.data.merge.suffix <- paste0("_f", data.freeze.date, "_m", data.merge.date)

merge.report.dir <- file.path(data.merge.dir, paste0("MAP_data_merge", current.data.merge.suffix))

dir_create(merge.report.dir)

data.merge.fm.file <- file.path(
  data.merge.dir, 
  paste0("MAP_fm_d", data.freeze.date, "_m", data.merge.date)
)
data.merge.bh.file <- file.path(
  data.merge.dir, 
  paste0("MAP_bh_d", data.freeze.date, "_m", data.merge.date)
)

if (!is.null(last.data.download.date) & is.null(last.data.merge.date)) {
  error("Please specify the last data merge date.")
} else if (is.null(last.data.download.date) & !is.null(last.data.merge.date)) {
  error("Please specify the last data download date.")
} else if (is.null(last.data.download.date) & is.null(last.data.merge.date)) {
  # extract date of previous data merge
  last.data.merge.suffix <- file.info(
    list.files(
      path = data.merge.dir,
      pattern = "MAP\\_bh\\_d\\d{8}\\_m\\d{8}.rds",
      full.names = T
    )
  ) %>%
    tibble::rownames_to_column(., var = "path") %>%
    arrange(desc(mtime)) %>%
    filter(row_number() == 1) %>%
    pull(1) %>%
    stringr::str_extract("(?<=(MAP\\_bh\\_))d\\d{8}\\_m\\d{8}")
} else {
  last.data.merge.suffix <- paste0("d", last.data.download.date, "_m", last.data.merge.date)
}

# define path to previous merged datasets
last.data.merge.fm.file <- file.path(
  data.merge.dir, 
  paste0("MAP_fm_", last.data.merge.suffix)
)
last.data.merge.bh.file <- file.path(
  data.merge.dir, 
  paste0("MAP_bh_", last.data.merge.suffix)
)
```

```{r}
full.freeze.date <- format(ymd_hm(MAPfreeze.list$general$timestamp), '%B %d, %Y')
full.freeze.dttm <- format(ymd_hm(MAPfreeze.list$general$timestamp), '%B %d, %Y at %H:%M')
full.modified.date <- format(Sys.time(), '%B %d, %Y')
full.modified.dttm <- format(Sys.time(), '%B %d, %Y at %H:%M')
```

# Data Freeze Info

**The data used in this merge was frozen on `r paste0(full.freeze.dttm)`.**

## REDCap Downloaded Data

```{r}
raw_data_info <- function(list = MAPfreeze.list, index) {
  tibble(
    project = list[[index]][["project"]],
    rows = dim(list[[index]][["data"]])[1],
    cols = dim(list[[index]][["data"]])[2]
  )
} 

purrr::map_dfr(2:5, ~ raw_data_info(index = .x))
```

## Static (Unchanging) Data

```{r}
static.length <- length(MAPfreeze.list[["static"]][["project"]])

list(
  project = MAPfreeze.list[["static"]][["project"]],
  rows = sapply(1:static.length, function(x) nrow(MAPfreeze.list[["static"]][["data"]][[x]])),
  cols = sapply(1:static.length, function(x) ncol(MAPfreeze.list[["static"]][["data"]][[x]]))
) %>% bind_rows()
```

# Data Pre-Processing

Here we will pre-process the VMAP EDC data due to its repeated instruments structure.

```{r}
pre_vmap_edc_temp.df <- MAPfreeze.list$vmap_edc$data %>%
  mutate(
    epoch = case_when(
      redcap_event_name == "eligibility_arm_1" ~ 0L,
      redcap_event_name == "enrollmentbaseline_arm_1" ~ 1L,
      redcap_event_name == "18month_followup_arm_1" ~ 2L,
      redcap_event_name == "3year_followup_arm_1" ~ 3L,
      redcap_event_name == "5year_followup_arm_1" ~ 4L,
      redcap_event_name == "7year_followup_arm_1" ~ 5L,
      redcap_event_name == "9year_followup_arm_1" ~ 6L,
      redcap_event_name == "11year_followup_arm_1" ~ 7L,
      redcap_event_name == "13year_followup_arm_1" ~ 8L,
      TRUE ~ NA_integer_
    )
  ) %>%
  relocate(
    epoch, .after = map_id
  ) %>%
  arrange(
    map_id, epoch
  ) %>%
  tibble()

pre_vmap_edc_non_repeating.df <- pre_vmap_edc_temp.df %>% # non-repeating data frame for brain scans to be left joined into
  filter(
    is.na(redcap_repeat_instrument)
  )

# check that there is only one row per participant and epoch
## pre_vmap_edc_non_repeating.df %>% count(map_id, epoch) %>% filter(n > 1)

pre_vmap_edc_repeating.df <- pre_vmap_edc_temp.df %>% # data frame with repeating instruments
  filter(
    !is.na(redcap_repeat_instrument)
  )

brain_mri.variables <- c("map_id", "epoch", "session_id", "scanner", "scanner_software", "head_coil", grep("_scan_acquired", names(pre_vmap_edc_repeating.df), v = T))

pre_vmap_edc_brain_mri.df <- pre_vmap_edc_repeating.df %>% # data frame with repeating instruments limited to brain MRI variables only
  filter(
    redcap_repeat_instrument == "brain_mri"
  ) %>% 
  select(
    all_of(brain_mri.variables)
  )
```

## Create brain MRI data frames to merge together

### Collapse `scan_acquired` variables

```{r}
pre_vmap_edc_brain_mri_scan_acquired.df <- pre_vmap_edc_brain_mri.df %>%
  select(
    map_id, epoch, all_of(grep("_scan_acquired", names(pre_vmap_edc_repeating.df), v = T))
  ) %>%
  group_by(map_id, epoch) %>%
  mutate(
    across(
      all_of(grep("_scan_acquired", names(pre_vmap_edc_repeating.df), v = T)),
      ~ 1 * (sum(.x, na.rm = TRUE) > 0),
      .names = "{.col}"
    )
  ) %>%
  slice(1) %>%
  ungroup()

# check that there is only one row per participant and epoch
## pre_vmap_edc_brain_mri_scan_acquired.df %>% count(map_id, epoch) %>% filter(n > 1)
```

### Create appropriate scanner variables for each brain MRI form

```{r}
brain_mri.metadata <- MAPfreeze.list$vmap_edc$metadata %>% 
  filter(
    field_name %in% c("session_id", "scanner", "scanner_software", "head_coil")
  )

pre_vmap_edc_scanner.df <- pre_vmap_edc_brain_mri.df %>% # data frame with repeating instruments limited to select scanner variables only
  select(
    c("session_id", "scanner", "scanner_software", "head_coil")
  ) %>% filter(
    !is.na(session_id)
  ) %>%
  process_factor_variables(data = ., metadata = brain_mri.metadata) %>%
  select(
    session_id, scanner_factor, head_coil_factor, scanner_software_factor
  ) %>%
  mutate(
    scanner_factor = forcats::fct_recode(
      scanner_factor,
      "3Tb" = "3Tb Philips Acheiva system",
      "3Ta" = "3Ta Philips Acheiva system",
      "3TbUDHW" = "3Tb Philips Acheiva system updated digital hardware"
    ),
    head_coil_factor = forcats::fct_recode(
      head_coil_factor,
      "8chSENSE" = "8 channel SENSE head coil",
      "8chdStream" = "dStream 8 channel head coil",
      "32chdStream" = "dStream 32 channel head coil"
    ),
    scanner_software_factor = forcats::fct_recode(
      scanner_software_factor,
      "3.2.2.0" = "3.2.2/3.2.2.0",
      "5.1.7.1" = "5.1.7/5.1.7.1",
      "5.3.0.2" = "5.3.0/5.3.0.2",
      "5.3.0.3" = "5.3.0/5.3.0.3",
      "5.6.1.0" = "5.6.1/5.6.1.0"
    ),
  ) %>%
  mutate(
    scanner_coil_factor = paste0(scanner_factor, "; ", head_coil_factor),
    scanner_coil_software_factor = paste0(scanner_factor, "; ", head_coil_factor, "; ", scanner_software_factor)
  )

pre_vmap_edc_scanner.df[pre_vmap_edc_scanner.df$scanner_coil_factor == "NA; NA", "scanner_coil_factor"] <- NA
pre_vmap_edc_scanner.df[pre_vmap_edc_scanner.df$scanner_coil_software_factor == "NA; NA; NA", "scanner_coil_software_factor"] <- NA

pre_vmap_edc_scanner.df <- pre_vmap_edc_scanner.df %>%
  mutate(
    scanner_coil_factor = forcats::as_factor(scanner_coil_factor),
    scanner_coil_software_factor = forcats::as_factor(scanner_coil_software_factor)
  )
```

```{r}
form_names <- setdiff(unique(pre_vmap_edc_repeating.df$redcap_repeat_instrument), "brain_mri") # names of non-brain_mri forms

# form_names <- c("freesurfer", "multiatlas_stats", "lesion_segmentation_tool_stats", 
# "asl_multiatlas_stats", "vbm_qa_stats", "fsl_first_stats", "hippodeep", 
# "white_matter_stamper_stats", "veasl_stats", "dtiroi", "oxygen_extraction_fraction", 
# "neck", "circle_of_willis", "lacunar_infarcts", "perivascular_space", 
# "swi", "vessel_wall_imaging")

get_form_variables <- function(db = "vmap_edc", form) {
  tibble(
    form = form,
    variable = MAPfreeze.list[[db]][["metadata"]] %>% filter(form_name %in% form) %>% pull(field_name)
  )
}

form_variables.df <- bind_rows(
  tibble(
    form = "brain_mri",
    variable = brain_mri.variables
  ),
  map_df(.x = form_names, ~ get_form_variables(form = .x))
)
```

```{r}
indicator.df <- form_variables.df %>% 
  filter(grepl("indicator", .$variable)) %>%
  setNames(c("form", "indicator"))

session_id.df <- form_variables.df %>% 
  filter(grepl("session_id", .$variable)) %>%
  setNames(c("form", "session_id"))

breath_hold.df <- tibble(
  form = form_names,
  bh = TRUE
)

# the variables associated with these forms do not have a breath hold version, according to NJ's email on 2022-09-01 09:12 CT
form_names.bh_false <- c("oxygen_extraction_fraction", "asl_multiatlas_stats", "vessel_wall_imaging", "veasl_stats")

breath_hold.df[breath_hold.df$form %in% form_names.bh_false, "bh"] <- FALSE

lookup.df <- list(indicator.df, session_id.df, breath_hold.df) %>% 
  reduce(left_join, by = "form")
```

### Create scanner data frames for all neuroimaging forms

```{r version_two}
create_individual_form_df <- function(form) {
  
  session_indicator.var <- lookup.df[lookup.df$form == form, ] %>% pull(indicator)
  session_id.var <- lookup.df[lookup.df$form == form, ] %>% pull(session_id)
  form.var <- form_variables.df[form_variables.df$form == form, ] %>% pull(variable)
  
  form.var <- form.var[form.var %in% names(pre_vmap_edc_repeating.df)]
  
  prefix <- gsub("_session_id", "", session_id.var)
  
  pre_vmap_edc_scanner.df_mod <- pre_vmap_edc_scanner.df %>%
    setNames(
      paste0(prefix, "_", names(pre_vmap_edc_scanner.df))
    )
  
  output.df <- pre_vmap_edc_repeating.df %>%
    filter(redcap_repeat_instrument == form) %>%
    filter(.data[[session_indicator.var]] == 1) %>%
    select(
      map_id, epoch, all_of(form.var)
    ) %>%
    left_join(
      .,
      pre_vmap_edc_scanner.df_mod, 
      by = session_id.var
    )
  
  return(output.df)
}

neuroimaging.list <- map(
  .x = form_names,
  ~ create_individual_form_df(form = .x)
)

names(neuroimaging.list) <- form_names

# check each tibble in neuroimaging.list to make sure it has data. `hippodeep` is the only neuroimaging form where we exepct to not have data.
```

## Merge together all brain MRI data to create a master VMAP EDC data set

```{r}
variables_to_remove_from_non_repeating <- form_variables.df %>% 
  filter(
    variable %nin% c("map_id", "epoch")
  ) %>% 
  pull(variable)

pre_vmap_edc_non_repeating_v2.df <- pre_vmap_edc_non_repeating.df[, !(names(pre_vmap_edc_non_repeating.df) %in% variables_to_remove_from_non_repeating)]

vmap_edc_temp01.df <- c(list(pre_vmap_edc_non_repeating_v2.df), list(pre_vmap_edc_brain_mri_scan_acquired.df), neuroimaging.list) %>% 
  reduce(left_join, by = c("map_id", "epoch"))

# check that there are no duplicated variables
## grep("\\.x$", names(vmap_edc_temp01.df), v = T) # should be character(0)
```

# Data Processing

## Process VMAP EDC

```{r}
process_scanner_factor_variables <- function(data, metadata) {
  metadata.df <- metadata %>%
    filter(
      field_type == "radio"
    ) %>%
    select(
      c("field_name", "field_label", "select_choices_or_calculations")
    ) %>%
    filter(
      field_name %nin% c("scanner", "scanner_software", "head_coil")
    ) %>%
    as_tibble()
  
  if (!is.null(metadata.df)) {
    for (factor_var.i in metadata.df$field_name) {
      levels.list <- as.list(REDCapR::checkbox_choices(pull(metadata.df[metadata.df$field_name == factor_var.i, "select_choices_or_calculations"])))
      
      data[[paste0(factor_var.i, "_factor")]] <- factor(data[[factor_var.i]], levels = levels.list$id, labels = levels.list$label)
    }
  }
  
  return(data)
}
```

```{r}
vmap_edc_temp02.df <- vmap_edc_temp01.df %>%
  mutate(
    across(
      .cols = where(is.numeric),
      .fns = ~ replace(.x, .x %in% c(-1111*(6:9), 9999), NA)
    ),
    across(
      .cols = where(is.character),
      .fns = ~ replace(.x, .x %in% c("-6666", "-7777", "-8888", "-9999", "9999", "1111-11-11", "11/11/1111"), NA)
    ),
    across(
      .cols = where(lubridate::is.Date),
      .fns = ~ replace(.x, .x %in% as.Date("1111-11-11"), NA)
    )
  ) %>%
  as.data.frame()

###

vars_w_comparison_operators.var <- grep(
  "bld|np|csf|biomarkers",
  grep(
    "notes|flow|occup",
    names(vmap_edc_temp02.df)[grepl("(>|<)([[:space:]]*)(\\d+)", vmap_edc_temp02.df)],
    invert = T,
    v = T),
  v = T)

vars_w_comparison_operators.var <- setdiff(vars_w_comparison_operators.var, "bld_c_coag")

if (length(vars_w_comparison_operators.var) > 0) {
  for (var in vars_w_comparison_operators.var) {
    vmap_edc_temp02.df[, var] <- suppressWarnings(sapply(vmap_edc_temp02.df[, var], process_comparison_operators, USE.NAMES = FALSE))
  }
}

###

vmap_edc_temp03.df <- process_scanner_factor_variables(data = vmap_edc_temp02.df, metadata = MAPfreeze.list$vmap_edc$metadata)

###

# improperly_formatted_dttm.var <- grep("date_time$", names(vmap_edc_temp03.df), v = T)[sapply(vmap_edc_temp03.df[, grep("date_time$", names(vmap_edc_temp03.df), v = T)], is.character)]

# vmap_edc_temp04.df <- vmap_edc_temp03.df %>% 
#   mutate(
#     across(
#       .cols = all_of(improperly_formatted_dttm.var),
#       .fns = ~ mdy_hm(.x, truncated = 5)
#     )
#   )

###

vmap_edc_temp04.df <- convert_dates(vmap_edc_temp03.df)
```

### Copying data from Eligibility

Variables in the following REDCap forms are copied from eligibility to enrollment for all participants: `r print_tt(forms_to_pull_down_from_eligibility.var)`.

```{r}
forms_to_pull_down_from_eligibility.var <- c("informant_information", "map_interview_form_cognitive_changes", "map_interview_form_medical_history", "functional_activities_questionnaire", "family_history", "cdr_informant", "cdr_participant", "interview_summary", "diagnosis")

vars_to_pull_down_from_eligibility.var <- MAPfreeze.list$vmap_edc$metadata %>%
  filter(
    form_name %in% forms_to_pull_down_from_eligibility.var
  ) %>%
  pull(
    field_name
  )

vars_to_pull_down_from_eligibility.var <- c(vars_to_pull_down_from_eligibility.var, paste0(vars_to_pull_down_from_eligibility.var, "_factor"))

vars_to_pull_down_from_eligibility.var <- vars_to_pull_down_from_eligibility.var[vars_to_pull_down_from_eligibility.var %in% names(vmap_edc_temp04.df)]

vmap_edc_temp04.df[vmap_edc_temp04.df$epoch %in% c(0, 1), c("map_id", "epoch", vars_to_pull_down_from_eligibility.var)] <- vmap_edc_temp04.df[vmap_edc_temp04.df$epoch %in% c(0, 1), c("map_id", "epoch", vars_to_pull_down_from_eligibility.var)] %>%
  group_by(
    map_id
  ) %>%
  tidyr::fill(
    all_of(vars_to_pull_down_from_eligibility.var), .direction = "down"
  ) %>%
  ungroup()
```

Variables in the following REDCap forms are copied from eligibility to enrollment for the VMAP 2.0 cohort only (MAP ID > 336): `r print_tt(extra_forms_to_pull_down_from_eligibility.var)`. For VMAP 1.0, the data was already collected at enrollment.

```{r}
extra_forms_to_pull_down_from_eligibility.var <- c("gds", "qids")

extra_vars_to_pull_down_from_eligibility.var <- MAPfreeze.list$vmap_edc$metadata %>%
  filter(
    form_name %in% extra_forms_to_pull_down_from_eligibility.var
  ) %>%
  pull(
    field_name
  )

extra_vars_to_pull_down_from_eligibility.var <- c(extra_vars_to_pull_down_from_eligibility.var, paste0(extra_vars_to_pull_down_from_eligibility.var, "_factor"))

extra_vars_to_pull_down_from_eligibility.var <- extra_vars_to_pull_down_from_eligibility.var[extra_vars_to_pull_down_from_eligibility.var %in% names(vmap_edc_temp04.df)]

vmap_edc_temp04.df[vmap_edc_temp04.df$epoch %in% c(0, 1) & vmap_edc_temp04.df$map_id >= 337, c("map_id", "epoch", extra_vars_to_pull_down_from_eligibility.var)] <- vmap_edc_temp04.df[vmap_edc_temp04.df$epoch %in% c(0, 1) & vmap_edc_temp04.df$map_id >= 337, c("map_id", "epoch", extra_vars_to_pull_down_from_eligibility.var)] %>%
  group_by(
    map_id
  ) %>%
  tidyr::fill(
    all_of(extra_vars_to_pull_down_from_eligibility.var), .direction = "down"
  ) %>%
  ungroup()
```

### Joining end tidal CO~2~ variables (Physlog Data)

The following variables contain values of "--" instead of NA, causing them to be of character class. In this merge, they are manually coerced to numeric (hence the outputted warning messages): `asl_3t_bl_etco2e`, `asl_rest_trimmedmean2525_etco2`, `fmri_rest_trimmedmean2525_etco2`.

```{r}
physlog.df <- MAPfreeze.list$static$data$physlog.static %>%
  select(
    -session_id
  ) %>%
  mutate(
    across(
      c(asl_3t_bl_etco2e, asl_rest_trimmedmean2525_etco2, fmri_rest_trimmedmean2525_etco2),
      ~ as.numeric(.x)
    )
  )

vars_to_exclude_from_vmap_edc.var <- setdiff(names(physlog.df), c("map_id", "redcap_event_name"))

vmap_edc_temp05.df <- vmap_edc_temp04.df %>%
  select(
    -all_of(vars_to_exclude_from_vmap_edc.var)
  ) %>%
  left_join(
    physlog.df, by = c("map_id", "redcap_event_name")
  )
```

### Removing observations lacking chart finalization

```{r}
vmap_edc_temp06.df <- vmap_edc_temp05.df %>%
  filter(
    chart_finalization == 1 & chart_finalization_review == 1 & chart_merge == 1
  )
```

```{r}
vmap_edc.df <- vmap_edc_temp06.df
cat(paste0("NOTE: `vmap_edc.df` has ", nrow(vmap_edc.df), " rows and ", ncol(vmap_edc.df), " columns."))
```

## Process Questionnaires

```{r}
questionnaires_temp01.df <- MAPfreeze.list$questionnaires$data %>%
  mutate(
    epoch = case_when(
      redcap_event_name == "eligibility_arm_1" ~ 0L,
      redcap_event_name == "enrollmentbaseline_arm_1" ~ 1L,
      redcap_event_name == "18month_followup_arm_1" ~ 2L,
      redcap_event_name == "3year_followup_arm_1" ~ 3L,
      redcap_event_name == "5year_followup_arm_1" ~ 4L,
      redcap_event_name == "7year_followup_arm_1" ~ 5L,
      redcap_event_name == "9year_followup_arm_1" ~ 6L,
      redcap_event_name == "11year_followup_arm_1" ~ 7L,
      redcap_event_name == "13year_followup_arm_1" ~ 8L,
      TRUE ~ NA_integer_
    )
  ) %>%
  relocate(
    epoch, .after = map_id
  ) %>%
  group_by(
    vmac_id
  ) %>%
  tidyr::fill(
    map_id, .direction = "downup"
  ) %>%
  ungroup() %>%
  arrange(
    map_id, epoch
  ) %>%
  format_id()

###

questionnaires_temp02.df <- questionnaires_temp01.df %>%
  mutate(
    across(
      .cols = where(is.numeric),
      .fns = ~ replace(.x, .x %in% c(-1111*(6:9), 9999), NA)
    ),
    across(
      .cols = where(is.character),
      .fns = ~ replace(.x, .x %in% c("-6666", "-7777", "-8888", "-9999", "9999", "1111-11-11", "11/11/1111"), NA)
    ),
    across(
      .cols = where(lubridate::is.Date),
      .fns = ~ replace(.x, .x %in% as.Date("1111-11-11"), NA)
    )
  ) %>%
  mutate_at(
    grep("notes|date", grep("^ecogself\\_", names(.), value = T), value = T, invert = T),
    ~ missing_to_na(., equal.val = 0, restrict.sign = TRUE)
  ) %>%
  as.data.frame()

###

questionnaires_temp03.df <- process_factor_variables(data = questionnaires_temp02.df, metadata = MAPfreeze.list$questionnaires$metadata)

###

questionnaires_temp04.df <- convert_dates(questionnaires_temp03.df) # will output warnings -- see "Notes" section above

###

discard_medication.var <- grep("name$", grep("med\\d{2}", names(questionnaires_temp04.df), v = T), v = T, invert = T)

questionnaires_temp05.df <- questionnaires_temp04.df %>%
  select(
    !all_of(discard_medication.var)
  ) %>%
  tibble()

###

questionnaires_temp06a.df <- questionnaires_temp05.df %>% 
  filter(!is.na(redcap_repeat_instrument)) %>% 
  select(
    map_id, vmac_id, epoch, matches("med\\d+_name$")
  )

questionnaires_temp06b.df <- questionnaires_temp06a.df %>%
  group_by(vmac_id, epoch) %>%
  mutate(
    temp_suffix = row_number(),
    .before = "map_id"
  ) %>%
  tidyr::pivot_wider(
    names_from = temp_suffix,
    values_from = matches("med\\d+_name$"),
    names_glue = "med{formatC(as.numeric(gsub('med|name|_', '', .value)) + (15 * (as.numeric(temp_suffix) - 1)), width = 2, flag = '0')}_name"
  )

questionnaires_temp06b.df$redcap_repeat_instrument <- NULL

###

questionnaires_temp07.df <- questionnaires_temp05.df %>% 
  filter(is.na(redcap_repeat_instrument)) %>% 
  select(!matches("med\\d+_name$"))
         
questionnaires_temp07.df$redcap_repeat_instance <- NULL
questionnaires_temp07.df$redcap_repeat_instrument <- NULL

###

questionnaires_temp08.df <- left_join(questionnaires_temp07.df, questionnaires_temp06b.df, by = c("vmac_id", "map_id", "epoch")) %>%
  arrange(
    map_id, epoch
  )

# questionnaires_temp08.df %>% group_by(map_id) %>% filter(n() == 1) %>% select(map_id, epoch) %>% ungroup() # these participants only have eligibility data
```

```{r}
questionnaires.df <- questionnaires_temp08.df %>% as.data.frame()
cat(paste0("NOTE: `questionnaires.df` has ", nrow(questionnaires.df), " rows and ", ncol(questionnaires.df), " columns."))
```

## Process Biomarkers EDC

```{r}
biomarkers_temp01.df <- MAPfreeze.list$biomarkers$data %>%
  mutate(
    epoch = case_when(
      redcap_event_name == "eligibility_arm_1" ~ 0L,
      redcap_event_name == "enrollmentbaseline_arm_1" ~ 1L,
      redcap_event_name == "18month_followup_arm_1" ~ 2L,
      redcap_event_name == "3year_followup_arm_1" ~ 3L,
      redcap_event_name == "5year_followup_arm_1" ~ 4L,
      redcap_event_name == "7year_followup_arm_1" ~ 5L,
      redcap_event_name == "9year_followup_arm_1" ~ 6L,
      redcap_event_name == "11year_followup_arm_1" ~ 7L,
      redcap_event_name == "13year_followup_arm_1" ~ 8L,
      TRUE ~ NA_integer_
    )
  ) %>%
  relocate(
    epoch, .after = map_id
  ) %>%
  arrange(
    map_id, epoch
  )

###

biomarkers_temp02.df <- biomarkers_temp01.df %>%
  mutate(
    across(
      .cols = where(is.numeric),
      .fns = ~ replace(.x, .x %in% c(-1111*(6:9), 9999), NA)
    ),
    across(
      .cols = where(is.character),
      .fns = ~ replace(.x, .x %in% c("-6666", "-7777", "-8888", "-9999", "9999", "1111-11-11", "11/11/1111"), NA)
    ),
    across(
      .cols = where(lubridate::is.Date),
      .fns = ~ replace(.x, .x %in% as.Date("1111-11-11"), NA)
    )
  ) %>%
  as.data.frame()

###

vars_w_comparison_operators.var <- grep(
  "bld|np|csf|biomarkers",
  grep(
    "notes|flow|occup",
    names(biomarkers_temp02.df)[grepl("(>|<)([[:space:]]*)(\\d+)", biomarkers_temp02.df)],
    invert = T,
    v = T),
  v = T)

vars_w_comparison_operators.var <- setdiff(vars_w_comparison_operators.var, "bld_c_coag")

if (length(vars_w_comparison_operators.var) > 0) {
  for (var in vars_w_comparison_operators.var) {
    biomarkers_temp02.df[, var] <- suppressWarnings(sapply(biomarkers_temp02.df[, var], process_comparison_operators, USE.NAMES = FALSE))
  }
}

###

biomarkers_temp03.df <- convert_dates(biomarkers_temp02.df)
```

```{r}
biomarkers.df <- biomarkers_temp03.df
cat(paste0("NOTE: `biomarkers.df` has ", nrow(biomarkers.df), " rows and ", ncol(biomarkers.df), " columns."))
```

## Process `abp.static`

```{r}
abp.df <- MAPfreeze.list$static$data$abp.static

names(abp.df) <- gsub("\\.", "\\_", names(abp.df))

abp.df <- abp.df %>%
  clear_labels() %>%
  convert_dates() %>%
  mutate(
    across(
      .cols = where(is.numeric),
      .fns = ~ replace(.x, .x %in% c(-1111*(6:9), 9999), NA)
    ),
    across(
      .cols = where(is.character),
      .fns = ~ replace(.x, .x %in% c("-6666", "-7777", "-8888", "-9999", "9999", "1111-11-11", "11/11/1111"), NA)
    ),
    across(
      .cols = where(lubridate::is.Date),
      .fns = ~ replace(.x, .x %in% as.Date("1111-11-11"), NA)
    )
  ) %>%
  mutate(
    epoch = 1L, .after = map_id
  )
```

```{r}
cat(paste0("NOTE: `abp.df` has ", nrow(abp.df), " rows and ", ncol(abp.df), " columns."))
```

# Data Merge {.tabset .tabset-fade .tabset-pills}

```{r}
vmap_edc_with_eligibility.df <- vmap_edc.df
vmap_edc.df <- vmap_edc.df %>% filter(epoch != 0)
```

```{r}
merged_temp01.df <- left_join(
  vmap_edc.df, abp.df, by = c("map_id", "epoch")
)

merged_temp02.df <- left_join(
  merged_temp01.df, questionnaires.df, by = c("map_id", "epoch", "vmac_id", "redcap_event_name"), suffix = c(".vmap_edc", ".questionnaires")
)

merged.df <- left_join(
  merged_temp02.df, biomarkers.df, by = c("map_id", "epoch", "redcap_event_name")
)

merged.df <- merged.df %>%
  arrange(
    map_id, epoch, redcap_repeat_instrument#, redcap_repeat_instance
  )
```

```{r}
merged.orig <- merged.df.bkup <- merged.df
merged.df <- merged.df.bkup <- merged.orig
# dim(merged.df)
cat(paste0("NOTE: `merged.df` begins with ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Merge Additional Epoch-Independent Data {.tabset .tabset-fade .tabset-pills}

### Add APOE genetic data

```{r}
apoe.df <- MAPfreeze.list$apoe$data %>%
  select(
    map_id, rs429358_allele, rs7412_allele, alleles
  )

merged.df %<>% left_join(
  apoe.df,
  by = "map_id"
) 
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

### Add ABPM consent data

```{r}
tracking.static.df <- MAPfreeze.list$static$data$tracking.static %>%
  select(
    map_id, elig_visit_consent_abpm, elig_visit_consent_lp, elig_visit_consent_lp_ineligible
  ) %>%
  rVMAP::format_id(.) %>%
  mutate(
    across(
      .cols = where(is.numeric),
      .fns = ~ replace(.x, .x %in% c(-1111*(6:9), 9999), NA)
    ),
    across(
      .cols = where(is.character),
      .fns = ~ replace(.x, .x %in% c("-6666", "-7777", "-8888", "-9999", "9999", "1111-11-11", "11/11/1111"), NA)
    ),
    across(
      .cols = where(lubridate::is.Date),
      .fns = ~ replace(.x, .x %in% as.Date("1111-11-11"), NA)
    )
  )

merged.df %<>% left_join(
  tracking.static.df,
  by = "map_id"
) %>% 
  mutate(
    abp_consent = ifelse(epoch == 1, elig_visit_consent_abpm, NA),
    abp_consent_factor = factor(abp_consent, levels = c(0, 1), labels = c("No", "Yes")) 
  )
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

### Add polygenetic risk score data

```{r}
polygenetic.df <- MAPfreeze.list$static$data$polygenetic.static
names(polygenetic.df) <- tolower(names(polygenetic.df))
names(polygenetic.df)[1] <- "map_id"

merged.df %<>% left_join(
  polygenetic.df,
  by = "map_id"
)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

# Post-Merge (Pre-Derivation) Modifications

## Convert time duration variables (`hms` class) to time variables (`character` class)

```{r}
hms.var <- names(merged.df)[sapply(merged.df, function(x) "hms" %in% class(x))]

for (var.i in hms.var) {
  merged.df[, var.i] <- lubridate::seconds_to_period(merged.df[, var.i])
  merged.df[, var.i] <- sprintf('%02d:%02d', hour(merged.df[, var.i]), minute(merged.df[, var.i]))
  merged.df[, var.i] <- na_if(merged.df[, var.i], "NA:NA")
}
```

## Manual Invalidation: Pre-Derivation

### Brain cyst related variable invalidation

The following variables are manually invalidated for MAP ID 163 due to the presence of a brain cyst: `r print_tt(map_163_invalid_variables.var)`.

```{r}
map_163_invalid_variables.var <- MAPfreeze.list$static$data$map_163_invalidation.static %>%
  pull(., 1)

merged.df[merged.df$map_id == "163", intersect(names(merged.df), map_163_invalid_variables.var)] <- NA
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

### Color blind related variable invalidation

MAP IDs 028, 033, 131, 169, 176, 201 require the following color-related variables to be invalidated due to color blindness: `r print_tt(color_blind.var)`.

```{r}
color_blind.var <- Hmisc::Cs(
  np_color,
  np_color_sscore,
  np_word,
  np_word_sscore,
  np_inhibit,
  np_inhibit_sscore,
  np_colorword_sum,
  np_colorword_comp,
  np_inhibitcolor_diff,
  np_inhibitcolor_contrast,
  np_color_scerr,
  np_color_ucerr,
  np_color_err,
  np_color_cumperc_err,
  np_word_scerr,
  np_word_ucerr,
  np_word_err,
  np_word_cumperc_err,
  np_inhibit_scerr,
  np_inhibit_cumperc_scerr,
  np_inhibit_ucerr,
  np_inhibit_cumperc_ucerr,
  np_inhibit_err,
  np_inhibit_err_sscore
)

merged.df <- invalidate_color_blind(merged.df)
```

```{r}
merged.df.pre_np_invalid <- merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

### Neuropsychological variable invalidation

```{r}
invalid_np.df <- MAPfreeze.list$static$data$invalid_neuropsych.static %>%
  format_id() %>%
  filter(
    epoch != 0
  ) %>%
  mutate(
    test = trimws(test)
  ) %>%
  arrange(
    epoch, map_id
  )

invalid_np.df <- bind_rows(
  invalid_np.df,
  invalid_np.df %>% mutate(test = paste0(test, "_factor"))
) %>%
  filter(
    test %in% names(merged.df)
  ) %>%
  as.data.frame()

for (row.i in 1:nrow(invalid_np.df)) {
  invalidation.df <- invalid_np.df[row.i, ]
  merged.df[merged.df$map_id == invalidation.df$map_id & merged.df$epoch == invalidation.df$epoch, invalidation.df$test] <- NA
}
```

```{r}
merged.df.post_np_invalid <- merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Set any infinite values that result from dividing by zero in REDCap formulas to missing

```{r}
is.na(merged.df) <- sapply(merged.df, is.infinite)
```

```{r}
merged.df.pre_format_names <- merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

# Format Variable Names and Apply Labels to Each Variable

```{r}
merged.df <- rVMAP::format_names(merged.df)
```

```{r}
format_metadata <- function(data) {
  data %>%
    dplyr::select(
      one_of(
        c("field_name", "form_name", "field_type", "field_label", "select_choices_or_calculations", "field_annotation")
      )
    ) %>%
    dplyr::mutate(
     field_name = gsub("\\_", "\\.", field_name)
    )
}

abp.labels <- tibble(
  field_name = gsub("\\.", "\\_", names(MAPfreeze.list$static$data$abp.static))[-1],
  form_name = NA,
  field_type = NA,
  field_label = sapply(MAPfreeze.list$static$data$abp.static, Hmisc::label)[-1],
  select_choices_or_calculations = NA,
  field_annotation = NA
)

metadata.df <- list(
  MAPfreeze.list[["vmap_edc"]][["metadata"]],
  abp.labels,
  MAPfreeze.list[["questionnaires"]][["metadata"]] %>% filter(!field_name %in% c("map_id", "vmac_id", "consent_proxy")),
  MAPfreeze.list[["biomarkers"]][["metadata"]] %>% filter(!field_name %in% c("map_id", "vmac_id", "consent_proxy")),
  MAPfreeze.list[["apoe"]][["metadata"]] %>% filter(field_name %in% c("rs429358_allele", "rs7412_allele", "alleles"))
) %>%
  bind_rows()

metadata.df <- format_metadata(metadata.df)

metadata.factor.df <- metadata.df %>%
  filter(
    field_name %in% gsub("\\.factor", "", grep("\\.factor", names(merged.df), v = T))
  ) %>%
  mutate(
    field_name = paste0(field_name, ".factor")
  )

strip_html <- function(string) {
  return(gsub("<.*?>", "", string))
}

labels.df <- bind_rows(metadata.df, metadata.factor.df) %>%
  filter(
    field_name %in% names(merged.df)
  ) 

whitespace_labels.var <- labels.df %>% filter(grepl("\\\n", field_label)) %>% pull(field_name)
whitespace_labels.var <- whitespace_labels.var[grep("factor", whitespace_labels.var, invert = TRUE)]
whitespace_labels.var <- gsub("\\.", "\\_", whitespace_labels.var)

html_factor_labels.var <- labels.df %>% filter(grepl("<.*?>", select_choices_or_calculations)) %>% pull(field_name)
html_factor_labels.var <- html_factor_labels.var[grep("factor", html_factor_labels.var, invert = TRUE)]
html_factor_labels.var <- gsub("\\.", "\\_", html_factor_labels.var)

labels.df <- labels.df %>%
  mutate(
    field_label = stringr::str_squish(field_label)
  ) %>%
  mutate(
    select_choices_or_calculations = strip_html(select_choices_or_calculations)
  )

for (var.i in labels.df$field_name) {
  Hmisc::label(merged.df[, var.i]) <- pull(labels.df[labels.df$field_name == var.i, "field_label"])[1]
}

label(merged.df$epoch) <- "Epoch"
```

The following pre-derivation variables (excluding those containing the strings `'complete'`, `'...'`, `'score'`, or `'factor'`) do not have labels:

```{r}
tibble(variables_without_labels = sort(grep("complete|\\.\\.\\.|score|factor", names(merged.df)[lapply(merged.df, function(x) label(x)) == ""], v = T, invert = T)))
```

# Add Units to Each Variable

```{r}
units.all <- metadata.df %>% 
  dplyr::distinct(field_name, field_annotation, .keep_all = TRUE)

units.all %<>%
  select(field_name, field_annotation) %>%
  drop_na() %>%
  filter(
    !grepl("^\\@", field_annotation)
  )

units.df <- units.all %>%
  filter(
    field_name %in% names(merged.df)
  ) %>%
  mutate(
    field_annotation = stringr::str_squish(field_annotation)
  )

for (var.i in units.df$field_name) {
  units(merged.df[, var.i]) <- pull(units.df[units.df$field_name == var.i, "field_annotation"])[1]
}
```

```{r}
merged.df.pre_deriv <- merged.df.bkup <- merged.df
merged.df <- merged.df.bkup <- merged.df.pre_deriv
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

# Derivation of New Variables {.tabset .tabset-fade .tabset-pills}

## Dates

Derive, label, and add date variables to the merged data set.

```{r derive-dates}
merged.df <- derive_dates(merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Demographics

Derive, label, and add demographic variables to the merged data set.

```{r derive-demographic}
merged.df <- derive_demographics(merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## APOE

Derive, label, and add APOE variables to the merged data set.

```{r derive-apoe}
merged.df <- call_function("derive_apoe", merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Medication and Surgery

Derive, label, and add medication and surgery variables to the merged data set.

```{r derive-medicationsAndSurgery}
merged.df <- call_function("derive_medication_surgery", merged.df,
  diabetes.file                    = MAPfreeze.list$static$data$diabetes.static,
  cholesterol.file                 = MAPfreeze.list$static$data$cholesterol.static,
  afib.file                        = MAPfreeze.list$static$data$afib.static,
  afib_surgery.file                = MAPfreeze.list$static$data$afibsurg.static,
  AH_beta_blocker.file             = MAPfreeze.list$static$data$antihypBetaBlocker.static,
  AH_beta_blocker_if_not_drop.file = MAPfreeze.list$static$data$antihypBetaBlockerIfNotDrop.static,
  AH_ace_inhibitor.file            = MAPfreeze.list$static$data$antihypACEInhib.static,
  AH_arb.file                      = MAPfreeze.list$static$data$antihypARB.static,
  AH_ccb.file                      = MAPfreeze.list$static$data$antihypCCB.static,
  AH_ksd.file                      = MAPfreeze.list$static$data$antihypKSD.static,
  AH_other.file                    = MAPfreeze.list$static$data$antihypOther.static
)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Blood Values

Derive, convert, label, and add blood variables to the merged data set.

```{r derive-bloodConversion}
merged.df <- call_function("derive_blood", merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Medical History

Derive, label, and add medical history variables to the merged data set.

```{r derive-medhxEtc}
cmr.findings.rhythm.afib <- c(
  "atrial fibrillation"
)

cmr.findings.rhythm.normal <- c(
  "sinus"                                                ,
  "sinus with frequent pvcs"                             ,
  "sinus with frequent pvcs,"                            ,
  "sinus with atrial bigeminy"                           ,
  "sinus with frequent pacs"                             ,
  "sinus arrhythmia"                                     ,
  "sinus with intermittent second degree av block"       ,
  "sinus with frequent pvcs (often in trigeminy)"        ,
  "small"                                                ,
  "sinus with ivcd"                                      ,
  "sinus with frequent pvcs often in a trigeminy pattern"
)

merged.df <- derive_medical_hx(merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Cardiac MRI

Derive, label, and add CMR variables to the merged data set.

```{r derive-cmr}
merged.df <- call_function("derive_cardiac_mri", merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Thigh

Derive, label, and add thigh variables to the merged data set.

```{r derive-thigh}
merged.df <- call_function("derive_thigh", merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Cardiac Structure

Derive, label, and add cardiac structure variables to the merged data set.

```{r derive-cardiacStructure}
merged.df <- call_function("derive_cardiac_structure", merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## ABP QC

Derive, label, and add ABP QC variables to the merged data set.

```{r derive-abpqc}
merged.df <- call_function("derive_abp_qc", merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## FSRP

Derive, label, and add FSRP variables to the merged data set.

```{r derive-fsrp}
merged.df <- call_function("derive_fsrp", merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Cognitive Complaint, FCADL, and FAQ

Derive, label, and add cognitive complaint, FCADL, and FAQ variables to the merged data set.

```{r derive-cognitiveComplaint}
merged.df <- call_function("derive_cognitive_complaint", merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Neuropsychological Variables

Derive, label, and add neuropsychological variables to the merged data set.

```{r derive-neuropsych}
merged.df <- call_function("derive_neuropsych", merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## MLTA and CHAMPS

Derive, convert, label, and add MLTA and CHAMPS variables to the merged data set.

```{r}
merged.df <- merged.df %>%
  mutate_at(
    grep("mlta\\d+$|champs\\d+\\.hrs$|champs\\d+\\.wk$", names(.), v = T),
    as.numeric
  )
```

```{r derive-mltaChamps}
merged.df <- call_function("derive_mlta_champs", merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Depression

Derive, label, and add depression variables to the merged data set.

```{r derive-depression}
merged.df <- call_function("derive_depression", merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Biomarkers

Derive, label, and add biomarker variables to the merged data set.

```{r derive-biomarkers}
# merged.df <- call_function("derive_biomarkers", merged.df)
merged.df <- derive_biomarkers(merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Informant Information 

Derive, label, and add informant information variables to the merged data set.

```{r derive-informatInfo}
merged.df <- call_function("derive_informant_info", merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Diagnosis and Staging

Derive, label, and add diagnosis and staging variables to the merged data set.

```{r derive-diagnosisAndStaging}
merged.df <- call_function("derive_diagnosis_staging", merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## PSQI

Derive, label, and add PSQI variables to the merged data set.

```{r derive-psqi}
# merged.df <- call_function("derive_psqi", merged.df)
merged.df <- derive_psqi(merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Frailty

Derive, label, and add frailty variables to the merged data set.

```{r derive-frailty}
merged.df <- call_function("derive_frailty", merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Food Scan

Derive, convert, label, and add food scan variables to the merged data set.

```{r derive-foodScan}
merged.df <- call_function("derive_food_scan", merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## PVLT

Derive, label, and add PVLT variables to the merged data set.

```{r}
pvlt.chr.var <- grep("np\\.pvlt", names(merged.df), value = T)[sapply(merged.df[, grep("np\\.pvlt", names(merged.df), value = T)], is.character)] %>%
  setdiff(., "np.pvlt.notes")

pvlt.chr.labels.df <- labels.df %>% filter(field_name %in% pvlt.chr.var)

# np.pvlt.sdfr.sdcr, np.pvlt.ldfr.ldcr, np.pvlt.sdfr.ldfr, np.pvlt.perc.free.intrus, np.pvlt.perc.cued.intrus

merged.df <- merged.df %>%
  mutate(
    across(
      .cols = all_of(pvlt.chr.var),
      .fns = ~ replace(.x, .x == "INF", NA) %>% as.numeric()
    )
  )

for (var.i in pvlt.chr.labels.df$field_name) {
  Hmisc::label(merged.df[, var.i]) <- pull(pvlt.chr.labels.df[pvlt.chr.labels.df$field_name == var.i, "field_label"])[1]
}
```

```{r derive-pvlt}
merged.df <- derive_pvlt(merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## CDR Conversion

Derive, label, and add CDR conversion variables to the merged data set.

```{r derive-cdr-conversion}
merged.df <- call_function("derive_cdr_conversion", merged.df)
class(merged.df) <- "data.frame"
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Circle of Willis (CoW) Variants

```{r derive-cow-variants}
merged.df <- call_function("derive_cow_variants", merged.df)
class(merged.df) <- "data.frame"
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## CVD/AFib Ever

```{r cvd-afib-ever}
merged.df <- call_function("derive_cvdafib_ever", merged.df)
```

```{r}
merged.df.post_derivation_pre_invalidation <- merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

# Post-Derivation Modifications

## Manual Invalidation: Post-Derivation

In this section, we will invalidate certain derived variables for specified individuals as requested by VMAC.

```{r invalidate-derived-np}
merged.df <- call_function("invalidate_derived_neuropsych_items", merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Repeat Baseline Variables at Each Epoch

```{r repeatBaseline}
enrollment_vars <- Cs(
  dob,
  education,
  sex.factor,
  race.factor,
  ethnicity.factor,
  raceethnicity.factor,
  lang.prim.factor,
  alleles,
  alleles.factor,
  rs429358.allele,
  rs7412.allele,
  apoe2pos,
  apoe4pos,
  apoe2count,
  apoe4count,
  apoe2pos.factor,
  apoe4pos.factor,
  pgc.score,
  pgc.noapoe.score
)

baseline_vars <- Cs( # will have ".base" appended to the end
  diagnosis.factor,
  mci.stage.factor, 
  innotest.albert.mci.stage.factor,
  mod.innotest.albert.mci.stage.factor,
  lumipulse.albert.mci.stage.factor,
  mod.lumipulse.albert.mci.stage.factor,
  age
)

to_repeat.df <- merged.df[merged.df$epoch %in% 1, c('map.id', enrollment_vars, baseline_vars)]

for (var.i in baseline_vars) {
  label(to_repeat.df[[var.i]]) <- paste0(label(to_repeat.df[[var.i]]), ", from Enrollment")
}

names(to_repeat.df) <- c('map.id', enrollment_vars, paste0(baseline_vars, ".base"))

merged.df <- merged.df[, names(merged.df)[!names(merged.df) %in% enrollment_vars]] %>% 
  left_join(
    to_repeat.df,
    by = "map.id"
  )
```

**The following variables were pulled from baseline (Epoch 1) to all epochs for every participant:**

```{r}
print(tibble(`New Variables` = setdiff(names(to_repeat.df), "map.id")))
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Modify Factor Levels

### Re-ordering levels in `diagnosis.factor` and `diagnosis.factor.base`

```{r reorder-dx-level}
merged.df <- merged.df %>%
  mutate(
    diagnosis.factor.base = forcats::fct_relevel(diagnosis.factor.base, "Normal", "Ambiguous At Risk", "MCI", "Dementia"),
    diagnosis.factor = forcats::fct_relevel(diagnosis.factor, "Normal", "Ambiguous At Risk", "MCI", "Dementia")
  )
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

### Setting reference to "No" for factor variables containing "No" as a level

```{r ref-level-no}
levels.list <- purrr::map(merged.df, levels)
factor_var.list <- levels.list[!purrr::map_lgl(levels.list, is.null)]

contains_no.list <- keep(factor_var.list, ~all("No" %in% .x))

# reference_yes.list <- factor_var.list[purrr::map(factor_var.list, 1) == "Yes"]

contains_no.var <- names(contains_no.list)

for (var.i in contains_no.var) {
  merged.df[[var.i]] <- relevel(merged.df[[var.i]], "No")
}
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

**Reference levels have been set to 'No' for the following variables:**

```{r print-refno-df}
print(data.frame(variables = contains_no.var))
```

# Final Derivations

## Automated 3T

Derive, label, and add automated 3T and ASL reactivity variables to the merged data set.

```{r derive-auto3T}
merged.df <- call_function("derive_automated_3T", merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## Manual 3T

Derive, label, and add manual 3T variables to the merged data set.

```{r derive-man3T}
merged.df <- call_function("derive_manual_3T", merged.df)
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

## AD Signature

Derive, label, and add AD signature McEvoy and Schwarz variables to the merged data set.

```{r derive-AD-sig}
merged.df <- derive_AD_signature(merged.df)
class(merged.df) <- "data.frame"
```

```{r}
merged.df.bkup.final <- merged.df
merged.df <- merged.df.bkup.final
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

# Adding Memory and Executive Function Composite Scores

**These scores were derived by Dandan Liu on September 12, 2022 in MPlus.**

```{r mem-ef-composite}
# composite.df <- readRDS("~/Box Sync/VMAC BIOSTAT/DATA/MAP/rawData/np_composite_20220912.rds")
composite.df <- MAPfreeze.list$static$data$np.composite.static

label(composite.df$map.id) <- label(merged.df$map.id)
label(composite.df$epoch) <- label(merged.df$epoch)

merged.df %<>% left_join(
  composite.df,
  by = c("map.id", "epoch")
)

label(merged.df$np.memory.composite) <- 'Memory Composite'
label(merged.df$np.executive.composite) <- 'EF Composite'
label(merged.df$diagnosis.factor) <- label(merged.df$diagnosis)
label(merged.df$diagnosis.factor.base) <- paste0(label(merged.df$diagnosis.factor), ", from Enrollment")
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

# Adding Biospecimen Availability

**Biospecimen availability was last updated on `20210719`.**

```{r biospecimen}
biospecimen.df <- process_biospecimen_availability(path = MAPfreeze.list$static$data$biospecimen_availability.static, epoch = 1L:5L)

label(biospecimen.df$map.id) <- label(merged.df$map.id)
label(biospecimen.df$epoch) <- label(merged.df$epoch)

merged.df <- left_join(merged.df, biospecimen.df, by = c("map.id", "epoch"))
```

```{r}
merged.df.bkup <- merged.df
merged.df <- merged.df.bkup
# dim(merged.df)
cat(paste0("NOTE: `merged.df` now has ", nrow(merged.df), " rows and ", ncol(merged.df), " columns."))
```

# Saving the Final Data

We will save the final data set to the `VMAC BIOSTAT/DATA/MAP/mergedData` directory as RDS and CSV files.

```{r save-data}
output_file_name <- paste0("f", data.freeze.date, "_m", format(Sys.time(), '%Y%m%d'))

saveRDS(merged.df, file = paste0("~/Box Sync/VMAC BIOSTAT/DATA/MAP/mergedData/MAP_fm_", output_file_name, ".rds"))
write.csv(merged.df, file = paste0("~/Box Sync/VMAC BIOSTAT/DATA/MAP/mergedData/MAP_fm_", output_file_name, ".csv"), row.names = FALSE)
```

# Current vs Previous Data Comparison

This section highlights changes between the current and previously generated data sets. Variables matching the following criteria will be excluded from the comparison:

- variable names that contain three consecutive dots
- variable names that start with "med" followed by one or more numbers
- variable names that contain "notes"
- variable names that start with "entry"
- variable names that contain "famhx" followed by one or more numbers
- variable names that end with "complete"

As part of the comparison process:

- variables will be stripped of their label and units attributes before being compared
- variables of class "integer" will be coerced to "numeric" before being compared
- variables of class "POSIXt" will be coerced to "character" before being compared
- strings will be flagged if a difference is detected in their first 75 characters only (i.e, variables of class "character" will be truncated to be 75 characters long)
- variables of class "factor" will be compared based on their labels, not their underlying numerical representation in R
- variables of class "numeric" will be flagged if they differ by more than a percentage tolerance defined as `0.00001` (`0.001%`)

```{r diff-setup}
if (is.null(last.data.merge.fm.file)) {
  warning("Please specify the download and merge dates for the previous data set.\n")
} else {
  merged.current.diff.df <- merged.df %>%
    clear_labels_and_units() %>%
    arrange(
      map.id, epoch
    )
  
  merged.current.diff.df <- merged.current.diff.df[, colSums(is.na(merged.current.diff.df)) < nrow(merged.current.diff.df)]
  
  ###
  
  merged.prev.diff.df <- readRDS(paste0(last.data.merge.fm.file, ".rds")) %>% 
    clear_labels_and_units() %>%
    arrange(
      map.id, epoch
    )
  
  merged.prev.diff.df <- merged.prev.diff.df[, colSums(is.na(merged.prev.diff.df)) < nrow(merged.prev.diff.df)]
  
  ###
  
  all.var <- union(names(merged.current.diff.df), names(merged.prev.diff.df))

  vars_to_exclude.var <- unique(c(
    grep("\\.{3}", all.var, v = T),
    grep("^med\\d+", all.var, v = T), 
    grep("notes", all.var, v = T), 
    grep("^entry", all.var, v = T), 
    grep("famhx\\d+", all.var, v = T),
    grep("complete$", all.var, v = T)
  ))
  
  keep.var <- all.var[!all.var %in% vars_to_exclude.var]
}

current.var <- keep.var[keep.var %in% names(merged.current.diff.df)] 
prev.var <- keep.var[keep.var %in% names(merged.prev.diff.df)]

merged.current.diff.df.bkup <- merged.current.diff.df
merged.prev.diff.df.bkup <- merged.prev.diff.df
```

```{r}
merged.current.diff.df <- merged.current.diff.df %>%
  select(
    all_of(current.var)
  ) %>%
  # modify_if(is.factor, as.character) %>%
  modify_if(is.integer, as.numeric) %>%
  modify_if(is.POSIXt, as.character)  %>% 
  mutate(
    across(
      where(is.character),
      ~ ifelse(nchar(.x) > 75, str_trunc(.x, width = 75+3), .x)
    )
  )

merged.prev.diff.df <- merged.prev.diff.df %>%
  select(
    all_of(prev.var)
  ) %>%
  # modify_if(is.factor, as.character) %>%
  modify_if(is.integer, as.numeric) %>%
  modify_if(is.POSIXt, as.character)  %>% 
  mutate(
    across(
      where(is.character),
      ~ ifelse(nchar(.x) > 75, str_trunc(.x, width = 75+3), .x)
    )
  )
```

```{r}
data_comparison <- comparedf(
  merged.current.diff.df, merged.prev.diff.df, 
  by = c("map.id", "epoch"),
  tol.num = "percent",
  tol.num.val = 0.00001,
  tol.factor = "labels" # match only factor labels
)

data_comparison.list <- summary(data_comparison)

write_csv(
  x = data_comparison.list$diffs.byvar.table %>% tibble() %>% arrange(desc(n)),
  file = file.path(
    merge.report.dir,
    paste0("data_differences_summary.csv")
  )
)

data_diffs <- diffs(data_comparison) %>%
  mutate(
    values.x = unlist(values.x),
    values.y = unlist(values.y)
  ) %>%
  filter(
    values.x != values.y
  )

write_csv(
  x = data_diffs,
  file = file.path(
    merge.report.dir,
    paste0("data_differences_detailed.csv")
  )
)
```

## New Variables in Current Data (Absent from Previous Data)

```{r}
new_vars.var <- current.var[which(current.var %nin% prev.var)]

DT::datatable(
  tibble(new_variable = new_vars.var),
  colnames = c('New Variable' = 'new_variable'),
  extensions = 'Buttons', options = list(
    dom = 'Bfrtip',
    buttons = c('copy', 'csv', 'excel')
  ),
  class = 'cell-border stripe'
)
```

# Session Info

```{r, echo=FALSE, include=FALSE}
session_info.list <- devtools::session_info()
platform.df <- tibble(
  setting = names(session_info.list$platform),
  value = unname(unlist(session_info.list$platform))
)
```

## Platform

```{r, echo=FALSE}
platform.df
```

## Loaded Packages

```{r, echo=FALSE}
as_tibble(x = session_info.list$packages[session_info.list$packages$attached == TRUE, ]) %>%
  select(Package = package, Version = loadedversion, Date = date, Source = source) %>%
  print(n = Inf)
```

```{r, echo=FALSE, include=FALSE}
beepr::beep(5)
```
